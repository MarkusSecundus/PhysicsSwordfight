\chapter{Návrh}

Nyní by již čtenář měl být seznámen s cílem naší práce i s nástroji, které k jeho dosažení hodláme použít. Přistupme tedy k návrhu našeho řešení.

V této kapitole nejprve čtenáři představíme objektový návrh, který bude použit při implementaci, a poté zevrubně prodiskutujeme metody zpracování uživatelského vstupu pro účely ovládání meče a hráčské postavy.


\section{Objektový návrh}

\subsection{Hráč}
\begin{itemize}
    \item skript co ovládá pohyb hráče a natočení kamery (SwordsmanMovement) - nezajímavá klasika
    \item orientační body podle kterých zpracovávají vstup jednotlivé stavy SwordMovementu (je potřeba aby se pohybovaly relativně vůči tělu hráče)
    \item jednoduchý capsule collider - pro kolize s environmentem apod.
    \item hráčský model (samostatný prefab) - bone rig, nese animátor, na každé kosti collidery co odpovídají části těla - pro kolize s nepřátelským mečem 
\end{itemize} 

\subsection{Meč} 
\begin{itemize}
    \item skript co ovládá pohyb meče (SwordMovement)
        \begin{itemize}
            \item stavový automat
            \item z editoru se konfiguruje seznam párů klávesa-stav + jeden defaultní stav
            \item stav... SwordMovement.Submodule
            \item každý stav nese nějaká data konfigurovaná z editoru, další data může získat od instance ISwordMovement, která do něj je injectnuta
            \item ISwordMovement - poskytuje deskriptor meče, zdroj vstupu, transform držitele meče a metodu MoveSword()
            \item aktuální stav je ten, jehož klávesa je právě stisknutá - na tom jediném je volán OnUpdate()
            \item v OnUpdate() stav vypočte žádanou pozici meče a s tou následně na SwordMovementu zavolá metodu MoveSword()
            \item MoveSword(struct poziceKamSeMečMáPohnout) - pohyb provádí SwordMovement v průběhu času jak sám uzná za vhodné (možné konfigurovat skrz jeho parametry v editoru)
        \end{itemize}
    \item vlastní model meče
        \begin{itemize}
            \item vyměnitelná podkomponenta, samostatnej prefab
            \item obsahuje mesh meče, collidery
            \item poskytuje \textbf{deskriptor-komponentu} ve které jsou uložené transformy odpovídající význačným bodům (ústí čepele, špička, blokovací bod apod.)
        \end{itemize}
\end{itemize} 

\subsection{Kořen hierarchie} 
\begin{itemize}
    \item Komponenta \textbf{SwordsmanAssembly}...
    \item Nese odpovědnost za to, že meč a šermíř budou správně pospojované (jeden s druhým a s objekty co jdou z vnější scény)
    \item Definují se tu odkazy na všechny objekty okolní scény, které meč nebo šermíř potřebují znát (kamera, healthbar, die-screen)
    \item Je v něm komponenta typu \textbf{ISwordInput} (abstrakce pro zdroj vstupu - klávesnice nebo ovládací skript)
    \item Definuje se tu tabulka dalších obecných parametrů, na které se komponenty uvnitř hráče a meče mohou symbolicky odkazovat (komponenta \textbf{SymbolMap})
    \item Všechny rozdíly, které odlišují \acs{PC} od \acs{NPC}, by se měly dít v tomto jednom objektu
\end{itemize} 

\subsection{Zhodnocení návrhu} 
\begin{itemize}
    \item Logika ovládání meče a ovládání hráčské postavy jsou dobře oddělené
    \item Logika meče dobře rozšiřitelná - jednoduché přidat nový ovládací submodul
    \item Není problém mít ten samý ovládací submodul několikrát na různých klávesách ale s jinými parametry
    \item Mezi SwordMovement a jeho mody není problém vecpat dekorátory (např. pro nahrávání rozkazů k pohybu meče)
    \item Abstrakce uživatelského vstupu... není problém ho mockovat, simulovat apod.
    \item Nevýhoda - Data hráče a meče nejsou dobře oddělená
        \begin{itemize}
            \item Detailní model hráče potřebuje mít k dispozici deskriptor meče, aby věděl, jak má napolohovat procedurální animaci rukou
            \item Orientační body, které používají některé mody meče, potřebují mít konstantní polohu relativně vůči tělu hráče -> musí být potomky jeho transformu, ne meče
        \end{itemize}
\end{itemize} 


\section{Zpracování uživatelského vstupu}

\subsection{Ovládání meče - úvodní zamyšlení}
\begin{itemize}
    \item k dispozici máme myš a klávesnici
    \item musí být pro hráče jednoduše uchopitelné (- ideálně tedy nějaký pěkně spojitý matematický formalizmus, který jsme pro hráče schopní pěkně vizualizovat)
    \item diskuze variant co používalo Die by the Sword:
        \begin{itemize}
            \item \textbf{Klávesnice} - zastaralý koncept, moderní hráč počítá, že k něčemu využije myš; stejně to tehdy byl jenom slabý odvar z toho, co uměla myš
            \item \textbf{Myš} - ze všech možností zvládá největší podmnožinu pohybů; vyžaduje cvik, ale umožňuje kreativitu a flexibilní reakce v nezvyklé situaci
            \item \textbf{Nahrávky} - na první pohled pěkná myšlenka, v praxi však neumožňují flexibilně reagovat na specifickou situaci (hráč je schopen si vést okamžitý myšlenkový přehled o příliš malém množství nahrávek)
        \end{itemize}
    \item výsledek diskuze:
        \begin{itemize}
            \item pro hráče chceme ovládání myší
            \begin{itemize}
                \item jinou možnost než něco s myší, nebo něco s klávesnicí stejně nemáme
                \item myš jediná má potenciál umožnit jemnou a flexibilní kontrolu (klávesnice má konečný počet kláves - konečný počet stavů)
            \end{itemize}
            \item interně implementujeme i přehrávání nahrávek - bude se hodit pro AI nepřítele (dává nám přímou, dobře uchopitelnou kontrolu nad jeho chováním a tedy obtížností hry) (jednoduchý systém, vhodný pro to v budoucnu sloužit jako základ, proti kterému budeme testovat sofistikovanější AI)
            \item nějaké kreativnější nápady než s čím už přišlo DbtS necháme na později. teď chceme mít něco, co už víme, že je základně použitelné, abysme vůči tomu později nové výstřelky mohli porovnávat
        \end{itemize}
    \item jakým formalizmem mapovat polohu myši na polohu meče?:
        \begin{itemize}
            \item nevíme jak přesně to na pozadí dělá DbtS
            \item jednoduchý, dobře vizualizovatelný formalismus.. střílet paprsek z kamery z místa kurzoru a protnout ho s nějakým útvarem 
            \item po dlouhé úvaze jsme se rozhodli, že pěkný útvar k protínání je kulová plocha
                \begin{itemize}
                    \item začneme s ní
                    \item buď se ukáže jako ideální
                    \item nebo se od ní odpíchneme abychom se dobrali k něčemu sofistikovanějšímu
                \end{itemize}
            \item DbtS umí pěkně mávat mečem ze strany na stranu. Co ale jiné typy pohybu, co člověk s mečem běžně dělá - např. blokování
                \begin{itemize}
                    \item mávání s mečem naimplementujeme plnohodnotně jako v DbtS 
                    \item bude však možné přepínat na další mody ovládání
                    \item vždy bude aktivní jenom jeden mod - přepínání stiskem příhodné klávesy (např. shift)
                    \item všechny mody berou na vstupu jeden bod - průnik kurzoru s kulovou plochou - a liší se v algoritmu, pomocí kterého z tohoto bodu určí cílovou polohu meče
                    \item přesnou matematiku na které stojí oba mody rozebereme později v implementační kapitole \textbf{\footnote{Je rozumný to takhle rozseknout?}} (viz \ref{modesOfSwordMovementSubsection})
                \end{itemize}
        \end{itemize}
\end{itemize}

\subsection{Ovládání meče - výsledek}
\begin{itemize}
    \item ovládání střílením paprsku, který se protne s kulovou plochou jsme naimplementovali
        \begin{itemize}
            \item fungovalo rámcově pěkně, ale byly zde nežádoucí okrajové případy (-> např. hráč mohl meč natočit tak, aby probodával jeho tělo)
            \item -> \textbf{kulová plocha je fajn, ale potřebuje zobecnit na něco trochu flexibilnějšího}
            \item rozhraní \textbf{IRayIntersectable} (actually to je abstraktní třída - protože Unity serializer) - metoda GetIntersection(Ray) - vrací struct - ten obsahuje zda byl úspěch, příp. bod průniku, střed proniknuté kulové plochy a váhu výsledku (pro účely interpolace)
            \item \textbf{RayIntersectableSphere}
                \begin{itemize}
                    \item definovaná středem a poloměrem
                    \item volitelný parametr - \textbf{díra}
                        \begin{itemize}
                            \item jiná RayIntersectableSphere
                            \item pokud se průnik paprsku nachází v díře (je vzdálený od jejího středu míň než její poloměr), nahlásí se jako netrefa, nebo se mu dle vzdálenosti od středu díry sníží váha
                            \item váhu výsledku (float 0-1), příp. její závislost na vzdálenosti průniku od středu díry konfiguruje uživatel skrz AnimationCurve
                            \item díry se ukázalo, že jsou potřeba, aby se při interpolaci (viz níže) mezi velkou a malou koulí dal udělat hladký přechod
                        \end{itemize}
                    \item další volitelný parametr - \textbf{center override}
                    \begin{itemize}
                        \item bod, který se bude ve výsledkovém structu hlásit jako centrum kulové plochy i když ve skutečnosti není
                        \item potřeba když interpolujeme mezi hodně velkou a hodně malou koulí - aby obě hlásily stejný střed
                    \end{itemize}
                \end{itemize}
            \item \textbf{RayIntersectableInterpolation}
                \begin{itemize}
                    \item list mnoha IRayIntersectables
                    \item GetIntersection volá sebe na všech podprvcích - výsledek je pak vážený aritmetický průměr těch, které byly trefené (vážený podle váhy udané ve výsledkovém structu)
                \end{itemize}
            \item Vizualizace - musí se střílet spousta paprsků z kamery 
            \item díky tomuhle jsme schopní hráči poskytnout průnikový tvar, co se pro něj tváří jako normální, intuitivní kulová plocha, ale proti ní zde máme spoustu dodatečné flexibility, která nám umožní vychytat okrajové případy
            \item pomocí tohohle se dají poskládat dost komplexní útvary, co se pořád tváří pěkně plynule a spojitě - ale nejsou plynulé a spojité vždycky, člověk si musí trochu pohrát s AnimationCurve u děr aby nebyly ostré přechody tam kde končí/začíná nějaká koule
            \item (insert vizualizaci jak vypadá IRayIntersectable kterej používá blocking mode)
            \item poznámka: k tomuto řešení jsme došli živelně experimentováním v průběhu času - teď když už je hotové, dost pravděpodobně by šlo najít alternativu, co by byla jednodušší a srovnatelně mocná (kdyby to někomu stálo za práci)
        \end{itemize}
\end{itemize}

\subsection{Ovládání postavy}
\begin{itemize}
    \item ovládání meče už máme - ale co zbytek?
    \item ideálně klasické WASD co všichni znají - funguje pro pohyb dopředu/dozadu a úskoky doleva/doprava
    \item problém - vertikální i horizontální osa kurzoru jsou potřeba pro účely meče - jak se má hráč rozhlížet do stran?
    \item rozhlížení nahoru/dolu - kosmetická záležitost kamery - když použijeme myš, zdá se být v pohodě
    \item rozhlížení doleva/doprava - udává směr chůze - nemůžeme jen tak dělat kurzorem, to by hráče mátlo když chce jenom sekat mečem 
    \item řešení - prostě na rozhlížení do stran použít klávesy QE - blbuvzdorné, dobře pochopitelné pro hráče, dobrý výchozí bod se kterým porovnávat při experimentech
    \item lepší řešení - možné téma budoucí práce
\end{itemize}


\section{Shrnutí}

V první části kapitoly jsme stanovili objektový návrh hlavních prvků našeho systému - šermíře a jeho meče. 

\textbf{Šermíř} je typickou herní postavou, která čte vstupy od uživatele a v závislosti na nich se pohybuje po herním světě (komponenta SwordsmanMovement). Je vybaven jednoduchým colliderem pro kolize s herním světem a detailním modelem, který koliduje s nepřátelskými meči a je procedurálně animován, aby se vizuálně tvářil držet vlastní meč (komponenta SwordsmanBodyProceduralAnimation). 

\textbf{Meč} je samostatným objektem v hierarchii. Drží si referenci na šermíře, jímž je držen, a při určování svého pohybu bere v úvahu jeho pozici. Celkově však probíhá pohyb meče plně v jeho vlastní režii - zodpovědnou komponentou je SwordMovement. Ta operuje jako stavový automat. Tvůrce hry v editoru nakonfiguruje seznam stavů (potomci třídy SwordMovement.Submodule) a jejich mapování na stisknuté klávesy, SwordMovement pak dle vstupu od uživatele vybírá, který stav je aktivní - na tom jediném volá metodu OnFixedUpdate. V této metodě submodul provádí libovolnou vnitřní logiku (konkrétní příklady ukážeme v \ref{modesOfSwordMovementSubsection}) a nakonec na instanci SwordMovement zavolá metodu MoveSword(), které jako argument předá žádanou pozici meče. SwordMovement se následně postará o jeho plynulý přesun. 

Meč i šermíř jsou dětmi společného \textbf{kořenového objektu} - jeho starostí je, aby byly meč a šermíř řádně pospojované jeden s druhým a s objekty vnějšího světa. Konfigurujeme zde např. zdroj uživatelského vstupu (komponenta dědící z ISwordInput) či reference na kameru a prvky GUI (healthbar apod.).

Celkově by tento návrh měl poskytovat dobrou rozšiřitelnost logiky pro ovládání meče (stačí přidat nový SwordMovement.Submodule), implementace počítačem řízených šermířů by tomuto návrhu rovněž neměla činit problém (stačí vyměnit zdroj vstupu a odebrat reference na GUI).

\bigbreak

Druhou část kapitoly jsme věnovali zamyšlení nad rozhraním, skrze které bude probíhat komunikace mezi hrou a hráčem - předně jsme se zaměřili na ovládání meče (které, jak jsme nastínili v \ref{gamesWithMoreDirectControll}, představuje těžký problém).

Rozhodli jsme se pro \textbf{ovládání pomocí myši}. Nejprve jsme zkusili provádět mapování tak, že jsme dle polohy kurzoru z kamery stříleli paprsek a ten protínali s kulovou plochou - průnik odpovídal bodu, kterým má procházet čepel meče\footnote{Toto platí při použití základního submodulu pro sekání. Obecně bod průniku slouží jako vstup, ze kterého instance SwordMovement.Submodule může vydedukovat cokoliv uzná za vhodné.}. Toto v praxi fungovalo vcelku pěkně a tvářilo se jako pro hráče intuitivně uchopitelný formalizmus. Vyskytovaly se zde však okrajové případy, které např. pro hráče činily jednoduchým, aby sám sebe mečem probodnul.

Proto jsme systém zobecnili - místo jediné kulové plochy je možné jich definovat několik a mezi jednotlivými průniky se počítá vážený průměr. Touto metodou jsme schopni zachovat vše, co na předchozí variantě fungovalo dobře, ale zároveň je nám poskytnuta dodatečná flexibilita, která umožňuje ošetřit okrajové případy.

Dále jsme stanovili ovládání pro \textbf{pohyb hráčské postavy ve světě} - v této oblasti nám nic nebránilo použít klasické WASD, pouze jsme museli přidat klávesy QE pro rozhlížení, protože kurzor je již plně zaměstnán ovládáním meče.

\bigbreak
Nyní tedy máme vypracovaný návrh jak pro rozhraní popisující moduly naší práce, tak i pro rozhraní, skrze které budou tyto moduly komunikovat s uživatelem. Můžeme tedy přistoupit k implementaci.
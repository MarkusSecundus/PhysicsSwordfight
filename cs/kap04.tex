\chapter{Návrh}

Nyní by již čtenář měl být seznámen s cílem naší práce i s nástroji, které k jeho dosažení hodláme použít. Přistupme tedy k návrhu našeho řešení.

V této kapitole nejprve čtenáři představíme objektový návrh, který bude použit při implementaci, a poté zevrubně prodiskutujeme metody zpracování uživatelského vstupu pro účely ovládání meče a hráčské postavy.


\section{Objektový návrh}

Chceme vytvořit akční hru zaměřenou na boj s mečem. Základními požadavky tedy je, aby hráč mohl chodit po herním světě, máchat svou zbraní a tím zraňovat další entity. Takovými entitami může být víceméně cokoliv - např. trénovací panák nebo nosný trám nepřátelské věže - avšak bylo by pěkné, kdybychom umožnili, aby jedním z typů nepřátel byla i počítačem řízená verze hráčské postavy.


\subsection{Abstrakce uživatelského vstupu}

Než se pustíme do modelování herních entit, bude vhodné nejprve vytvořit abstrakci nad zdrojem uživatelského vstupu. Jak jsme čtenáři představili v \ref{unityInputExplanationSubsection}, vstup je tradičně získáván pomocí statických metod třídy UnityEngine.Input. To je metoda velmi rigidní - implikuje jediný globální zdroj vstupu pro všechny objekty, nad jehož obsahem navíc nemáme žádnou kontrolu. 

Co bychom chtěli je možnost konfigurovat různé zdroje vstupu pro různé objekty - např. hráčská postava může být ovládána pomocí hodnot získaných z UnityEngine.Input, počítačem řízení protivníci by o nich však neměli mít ponětí. Při vhodném návrhu by mělo stačit naprogramovat a otestovat hráčského šermíře a nepřátelského z něj následně vytvořit pouhou výměnou zdroje vstupu za vstup simulovaný algoritmem umělé inteligence.

Ustanovíme tedy rozhraní \textbf{ISwordInput}. Jeho metody budou pro jednoduchost rámcově odpovídat vybraným základním metodám z UnityEngine.Input. Jeho základní implementace - komponenta \textbf{BasicSwordInput} bude jednoduše volat odpovídající metody UnityEngine.Input, avšak nic nám nebrání vytvořit libovolně mnoho variant s jinou vnitřní logikou. 

Stanovíme konvenci, že každý objekt, jenž zpracovává uživatelský vstup, si jeho zdroj při své inicializaci najde v objektové hierarchii voláním GetComponentInParent<ISwordInput>() (viz \ref{howToSearchForComponentsSubsubsection}).


\subsection{Šermíř}

Nyní můžeme přistoupit k návrhu základních herních entit. 

Začněme postavou šermíře. Ten je samostatným herním objektem, jehož náplní práce je \textbf{pohybovat se po herním světě, držet meč a být zasahován nepřátelským mečem}. Pohybovat by se měl dle instrukcí získaných z hráčského vstupu, zároveň v jeho očích sídlí kamera, skrze kterou hráč herní svět vnímá.

Zodpovědnou za pohyb hráče a kamery stanovíme komponentu \textbf{SwordsmanMovement}. Ta bude znát několik pevně daných způsobů pohybu - chůze dopředu/dozadu, otáčení doleva/doprava, skok apod. - pro každý z nich konfigurované mapování vstupu, rychlost pohybu apod., a dle hodnot přečtených ze své instance ISwordInput bude tyto pohyby vykonávat. 

Jedním z dětí šermířského objektu bude \textbf{kamera}, která se otáčí za šermířovým pohledem. Avšak uzurpovat pro sebe skutečnou herní kameru není vhodné - v případě šermířovy smrti by pak kamera rovněž byla zničena a hra by se dostala do nekonzistentního stavu. Navíc nechceme, aby kameru ovládali nepřátelští šermíři. Místo skutečné kamery tedy budeme otáčet a polohovat její maketu - poslouží prázdný objekt s komponentou Transform - při inicializaci šermíře volitelně na skutečnou kameru umístíme jednoduchý skript, který bude jejich pozice synchronizovat.

Dalším dítětem šermířského objektu bude šermířův detailní animovaný model. Na něm bude umístěna soustava colliderů určených ke kolizi s nepřátelskými zbraněmi. Rovněž ponese komponentu \textbf{SwordsmanBodyProceduralAnimation} zodpovědnou za procedurální animaci šermířových rukou - aby se kosmeticky tvářily držet meč\footnote{Meč reálně držený v šermířových rukou by zkomplikoval náš návrh, umocnil nestabilitu fyzikální simulace a nepřinesl by nám mnoho benefitů - viz \ref{swordMovementMoveSwordImplementationSubsection}.}.


\subsection{Meč} 

Nejdůležitějším herním objektem našeho systému je meč. Jak jsme si stanovili v kapitole \ref{goalSettingChapter}, chceme, aby byl modulárně schopen přijímat různé metody ovládání a aby rozhraní, skrze které s ním ovládací moduly komunikují, umožnilo volný pohyb ve všech 6 stupních volnosti.

\subsubsection*{Moduly}

Protože každá z metod vstupu bude vynikat v jiné situaci, bylo by velmi příhodné, kdyby mezi nimi bylo možné přepínat velmi jednoduše v žáru boje - například stisknutím klávesy. Taková schopnost má potenciál celkovou flexibilitu ovládání znásobit - např. hráč může defaultně používat ovládací mod pro sekání, ale jakmile je třeba, bleskově přepnout do specializovaného modu pro blokování, následně provést protiútok přepnutím do dalšího modu specializovaného pro bodání. 

Nabízí se tedy ovladací komponentu \textbf{SwordMovement} implementovat jako \textbf{stavový automat}. Jednotlivé stavy - moduly - budou zodpovědné za výpočet polohy, kam se meč má přesunout. Samotná komponenta SwordMovement pak modulům poskytne rozhraní, skrze které přesun na konkrétní vypočtenou polohu vyžádají, a bude zodpovídat za průběh onoho přesunu. Rovněž bude třeba držet přehled, který modul je právě aktivní, a na tom si každý snímek vyžádat aktualizaci stavu.

Jak tedy vypadá náš hotový návrh? Abstraktní třídou, ze které moduly dědí, nechť je SwordMovement.Module. Ta definuje množinu funkcí jako OnActivated(), OnDeactivated(), OnFixedUpdate(), které na modulu jsou v závislosti na jeho stavu volány - každý modul je může overridovat vlastní logikou. Na začátku hry je rovněž do každého modulu injectnuta reference na ISwordMovement (podmnožina celkové funkcionality SwordMovement), která poskytuje zdroj uživatelského vstupu, deskriptor meče, transform šermíře, který meč drží, a konečně funkci MoveSword(), jejímž voláním skript vyžádá změnu polohy meče.

Seznam modulů lze konfigurovat z editoru. Každá instance SwordMovement definuje jeden výchozí modul (aktivní když žádná klávesa není stisknuta) a list key-value párů, kde klíčem je klávesa a hodnotou modul, který se stisknutím klávesy má aktivovat. Každý typ modulu rovněž může definovat dodatečná data, která z editoru lze konfigurovat (dle klasických pravidel serializace). Není problém mít definováno na různých klávesách dva moduly stejného typu, ale s různou konfigurací.

Metoda MoveSword(), kterou řidicí komponenta modulům poskytuje, bere jako argument strukturu, která udává cílovou polohu, natočení meče a rovněž dodatečné volitelné parametry - např. jakou silou má meč být držen. Vlastní pohyb meče do tohoto stavu je plně v režii komponenty SwordMovement - ta pouze ručí za to, že pohyb bude plynule rozprostřený v průběhu času a bude se chovat standardním způsobem bez ohledu na to, s jakou četností je MoveSword() voláno (ať již každý FixedUpdate či třeba jen jednou za sekundu).

\subsubsection*{Model meče}

Rovněž je třeba stručně zmínit samotný model meče. Ten zahrnuje jak mesh, který se bude vykreslovat na obrazovce, tak fyzikální collidery. V herní logice budeme potřebovat s mečem pracovat zjednodušeně jako s množinou jeho význačných bodů (špička a pata čepele, začátek a konec rukojeti apod.).

Model a collidery vytvoříme pomocí standardních komponent. Význačné body oproti tomu jsou velká množina prázdných herních objektů, se kterými pracovat jednotlivě by bylo velmi úmorné - vytvoříme tedy komponentu \textbf{SwordDescriptor}. Ta nechť definuje pro každý význačný bod pojmenovanou proměnnou, kam bod zkrátka přiřadíme v editoru. Do skriptů, které nad nimi operují, nyní stačí předat odkaz na tuto komponentu.


\subsection{Kořen hierarchie} 

Šermíř a meč dohromady tvoří jednu celistvou, hráčem ovladatelnou entitu. Potřebujeme tedy jeden objekt, který je bude oba zaštiťovat jako kořen prefabu a zaručí, že jsou vzájemně korektně pospojované. Obě tyto komponenty rovněž potřebují komunikovat s objekty vnějšího světa - číst uživatelský vstup, polohovat kameru, updatovat healthbar,... - bylo by tedy vhodné, aby tento kořen hierarchie posloužil i jako spojník s vnějším světem. 

Za úspěch budeme považovat, pokud veškeré změny, jenž musí proběhnout k přetvoření hráčského šermíře na počítačem řízeného protivníka, omezeníme výhradně na obsah tohoto objektu.

\subsubsection*{Vstup}

Kořen hierarchie přirozeně bude místem, kde definujeme instanci \textbf{ISwordInput}. Šermíř i meč ji zde - ve svém předkovi - automaticky najdou aniž bychom museli vynakládat větší úsilí.

\subsubsection*{SwordsmanAssembly}

Komponentu \textbf{SwordsmanAssembly} určíme zodpovědnou za pospojování šermíře a meče dohromady. Rovněž bude zodpovídat za propojení šermíře s kamerou, jejíž referenci zde volitelně nakonfigurujeme. 

\subsubsection*{SymbolMap}

Komponent uživatelského rozhraní a dalších součástí vnějšího světa je větší množství a interakce s každou z nich probíhá specifickým způsobem - tu tedy nechme plně v režii interagujícího podobjektu. Zde poskytneme pouze možnost definovat reference na ně, na ty se následně objekty uvnitř budou moci symbolicky odkazovat.

Komponenta \textbf{SymbolMap} poskytne z editoru konfigurovatelný list, ve kterém můžeme skladovat reference na libovolné komponenty herního světa - ke každé přiřazený string s unikátním jménem. V komponentě uvnitř šermíře či meče pak můžeme definovat serializovatelnou proměnnou typu \textbf{Symbol} - uživatel v editoru zadá jméno, skript pak voláním symbol.Get() získá příslušnou komponentu.


\subsection{Systém zranění}

Posledním dílem skládačky naší hry je hráčova schopnost zraňovat další entity a být jimi zraňován. Pro jednoduchost volíme cestu tradičního systému bodů zdraví a zranění.

Zde najdeme 3 podstatné druhy komponent - \textbf{zbraň}, která udílí zranění, \textbf{oběť útoku}, jež zranění přijímá a případně je schopna zemřít, a konkrétní \textbf{část těla}, jež byla zasažena.

\subsubsection*{Damageable}

Komponenta v kořenu postavy, která definuje její body HP. Nabízí eventy pro situace, kdy je zraněna či léčena (aby bylo updatováno GUI apod.), v případě že HP klesnou na 0 buď může svůj herní objekt okamžitě zničit, či zavolat event, který provede zničení sofistikovaněji (např. hráče respawne). 

Změna HP se provádí voláním funkce ChangeHP(float) - předáváme-li kladný argument, je chápáno že jde o léčení, záporný argument znamená zranění.

\subsubsection*{Zbroj}

Zranění je typicky vyvoláno zasažením některé z částí těla postavy. Ty mohou být různě obrněné a nabízet různou míru tlumení útoku. Reprezentujeme je potomky třídy \textbf{IArmorPiece}.

Chceme-li vykonat útok na konkrétní kus zbroje, voláme funkci ProcessAttack(AttackDeclaration), kde AttackDeclaration je struktura nesoucí základní informace o bodu, kam byl proveden zásah, míře způsobeného zranění apod. . Instance zbroje následně přepočítá, jaké zranění bylo reálně způsobeno a zavolá ChangeHP() na Damageable, které nalezlo ve svém předkovi.

\subsubsection*{Zbraň}

Zbraň je jakýkoliv objekt, který je na IArmorPiece schopen volat ProcessAttack(). Může to být např. paprsek smrti řízený raycastem, avšak v našem případě to typicky bude fyzikální objekt, jenž deklaruje útok při kolizi s jiným objektem. 

Konkrétní implementací, kterou použijeme, je \textbf{BasicImpactWeapon}. Její náplň práce je zkrátka při každé zprávě OnCollisionEnter prozkoumat zasažený collider, zda někde v jeho předkovi není IArmorPiece - pokud je, vytvoří pro něj deklaraci útoku na základě bodu zásahu a síly kolize, jež mu byly nahlášeny fyzikálním systémem.

\subsection{Zhodnocení návrhu} 


\begin{itemize}
    \item Logika ovládání meče a ovládání hráčské postavy jsou dobře oddělené
    \item Logika meče dobře rozšiřitelná - jednoduché přidat nový ovládací submodul
    \item Není problém mít ten samý ovládací submodul několikrát na různých klávesách ale s jinými parametry
    \item Mezi SwordMovement a jeho mody není problém vecpat dekorátory (např. pro nahrávání rozkazů k pohybu meče)
    \item Abstrakce uživatelského vstupu... není problém ho mockovat, simulovat apod.
    \item Damage systém - velmi jednoduchý, ale obecný - poskytuje možnosti sofistikovaného rozšíření
    \item Nevýhoda - Data hráče a meče nejsou dobře oddělená
        \begin{itemize}
            \item Detailní model hráče potřebuje mít k dispozici deskriptor meče, aby věděl, jak má napolohovat procedurální animaci rukou
            \item Orientační body, které používají některé mody meče, potřebují mít konstantní polohu relativně vůči tělu hráče -> musí být potomky jeho transformu, ne meče
        \end{itemize}
\end{itemize} 





\section{Schéma ovládání}

\subsection{Ovládání meče - úvodní zamyšlení}
\begin{itemize}
    \item k dispozici máme myš a klávesnici
    \item musí být pro hráče jednoduše uchopitelné (- ideálně tedy nějaký pěkně spojitý matematický formalizmus, který jsme pro hráče schopní pěkně vizualizovat)
    \item diskuze variant co používalo Die by the Sword:
        \begin{itemize}
            \item \textbf{Klávesnice} - zastaralý koncept, moderní hráč počítá, že k něčemu využije myš; stejně to tehdy byl jenom slabý odvar z toho, co uměla myš
            \item \textbf{Myš} - ze všech možností zvládá největší podmnožinu pohybů; vyžaduje cvik, ale umožňuje kreativitu a flexibilní reakce v nezvyklé situaci
            \item \textbf{Nahrávky} - na první pohled pěkná myšlenka, v praxi však neumožňují flexibilně reagovat na specifickou situaci (hráč je schopen si vést okamžitý myšlenkový přehled o příliš malém množství nahrávek)
        \end{itemize}
    \item výsledek diskuze:
        \begin{itemize}
            \item pro hráče chceme ovládání myší
            \begin{itemize}
                \item jinou možnost než něco s myší, nebo něco s klávesnicí stejně nemáme
                \item myš jediná má potenciál umožnit jemnou a flexibilní kontrolu (klávesnice má konečný počet kláves - konečný počet stavů)
            \end{itemize}
            \item interně implementujeme i přehrávání nahrávek - bude se hodit pro AI nepřítele (dává nám přímou, dobře uchopitelnou kontrolu nad jeho chováním a tedy obtížností hry) (jednoduchý systém, vhodný pro to v budoucnu sloužit jako základ, proti kterému budeme testovat sofistikovanější AI)
            \item nějaké kreativnější nápady než s čím už přišlo DbtS necháme na později. teď chceme mít něco, co už víme, že je základně použitelné, abysme vůči tomu později nové výstřelky mohli porovnávat
        \end{itemize}
    \item jakým formalizmem mapovat polohu myši na polohu meče?:
        \begin{itemize}
            \item nevíme jak přesně to na pozadí dělá DbtS
            \item jednoduchý, dobře vizualizovatelný formalismus.. střílet paprsek z kamery z místa kurzoru a protnout ho s nějakým útvarem 
            \item po dlouhé úvaze jsme se rozhodli, že pěkný útvar k protínání je kulová plocha
                \begin{itemize}
                    \item začneme s ní
                    \item buď se ukáže jako ideální
                    \item nebo se od ní odpíchneme abychom se dobrali k něčemu sofistikovanějšímu
                \end{itemize}
            \item DbtS umí pěkně mávat mečem ze strany na stranu. Co ale jiné typy pohybu, co člověk s mečem běžně dělá - např. blokování
                \begin{itemize}
                    \item mávání s mečem naimplementujeme plnohodnotně jako v DbtS 
                    \item bude však možné přepínat na další mody ovládání
                    \item vždy bude aktivní jenom jeden mod - přepínání stiskem příhodné klávesy (např. shift)
                    \item všechny mody berou na vstupu jeden bod - průnik kurzoru s kulovou plochou - a liší se v algoritmu, pomocí kterého z tohoto bodu určí cílovou polohu meče
                    \item přesnou matematiku na které stojí oba mody rozebereme později v implementační kapitole \textbf{\footnote{Je rozumný to takhle rozseknout?}} (viz \ref{modesOfSwordMovementSubsection})
                \end{itemize}
        \end{itemize}
\end{itemize}

\subsection{Ovládání meče - výsledek}
\begin{itemize}
    \item ovládání střílením paprsku, který se protne s kulovou plochou jsme naimplementovali
        \begin{itemize}
            \item fungovalo rámcově pěkně, ale byly zde nežádoucí okrajové případy (-> např. hráč mohl meč natočit tak, aby probodával jeho tělo)
            \item -> \textbf{kulová plocha je fajn, ale potřebuje zobecnit na něco trochu flexibilnějšího}
            \item rozhraní \textbf{IRayIntersectable} (actually to je abstraktní třída - protože Unity serializer) - metoda GetIntersection(Ray) - vrací struct - ten obsahuje zda byl úspěch, příp. bod průniku, střed proniknuté kulové plochy a váhu výsledku (pro účely interpolace)
            \item \textbf{RayIntersectableSphere}
                \begin{itemize}
                    \item definovaná středem a poloměrem
                    \item volitelný parametr - \textbf{díra}
                        \begin{itemize}
                            \item jiná RayIntersectableSphere
                            \item pokud se průnik paprsku nachází v díře (je vzdálený od jejího středu míň než její poloměr), nahlásí se jako netrefa, nebo se mu dle vzdálenosti od středu díry sníží váha
                            \item váhu výsledku (float 0-1), příp. její závislost na vzdálenosti průniku od středu díry konfiguruje uživatel skrz AnimationCurve
                            \item díry se ukázalo, že jsou potřeba, aby se při interpolaci (viz níže) mezi velkou a malou koulí dal udělat hladký přechod
                        \end{itemize}
                    \item další volitelný parametr - \textbf{center override}
                    \begin{itemize}
                        \item bod, který se bude ve výsledkovém structu hlásit jako centrum kulové plochy i když ve skutečnosti není
                        \item potřeba když interpolujeme mezi hodně velkou a hodně malou koulí - aby obě hlásily stejný střed
                    \end{itemize}
                \end{itemize}
            \item \textbf{RayIntersectableInterpolation}
                \begin{itemize}
                    \item list mnoha IRayIntersectables
                    \item GetIntersection volá sebe na všech podprvcích - výsledek je pak vážený aritmetický průměr těch, které byly trefené (vážený podle váhy udané ve výsledkovém structu)
                \end{itemize}
            \item Vizualizace - musí se střílet spousta paprsků z kamery 
            \item díky tomuhle jsme schopní hráči poskytnout průnikový tvar, co se pro něj tváří jako normální, intuitivní kulová plocha, ale proti ní zde máme spoustu dodatečné flexibility, která nám umožní vychytat okrajové případy
            \item pomocí tohohle se dají poskládat dost komplexní útvary, co se pořád tváří pěkně plynule a spojitě - ale nejsou plynulé a spojité vždycky, člověk si musí trochu pohrát s AnimationCurve u děr aby nebyly ostré přechody tam kde končí/začíná nějaká koule
            \item (insert vizualizaci jak vypadá IRayIntersectable kterej používá blocking mode)
            \item poznámka: k tomuto řešení jsme došli živelně experimentováním v průběhu času - teď když už je hotové, dost pravděpodobně by šlo najít alternativu, co by byla jednodušší a srovnatelně mocná (kdyby to někomu stálo za práci)
        \end{itemize}
\end{itemize}

\subsection{Ovládání postavy}
\begin{itemize}
    \item ovládání meče už máme - ale co zbytek?
    \item ideálně klasické WASD co všichni znají - funguje pro pohyb dopředu/dozadu a úskoky doleva/doprava
    \item problém - vertikální i horizontální osa kurzoru jsou potřeba pro účely meče - jak se má hráč rozhlížet do stran?
    \item rozhlížení nahoru/dolu - kosmetická záležitost kamery - když použijeme myš, zdá se být v pohodě
    \item rozhlížení doleva/doprava - udává směr chůze - nemůžeme jen tak dělat kurzorem, to by hráče mátlo když chce jenom sekat mečem 
    \item řešení - prostě na rozhlížení do stran použít klávesy QE - blbuvzdorné, dobře pochopitelné pro hráče, dobrý výchozí bod se kterým porovnávat při experimentech
    \item lepší řešení - možné téma budoucí práce
\end{itemize}


\section{Shrnutí}

V první části kapitoly jsme stanovili objektový návrh hlavních prvků našeho systému - šermíře a jeho meče. 

\textbf{Šermíř} je typickou herní postavou, která čte vstupy od uživatele a v závislosti na nich se pohybuje po herním světě (komponenta SwordsmanMovement). Je vybaven jednoduchým colliderem pro kolize s herním světem a detailním modelem, který koliduje s nepřátelskými meči a je procedurálně animován, aby se vizuálně tvářil držet vlastní meč (komponenta SwordsmanBodyProceduralAnimation). 

\textbf{Meč} je samostatným objektem v hierarchii. Drží si referenci na šermíře, jímž je držen, a při určování svého pohybu bere v úvahu jeho pozici. Celkově však probíhá pohyb meče plně v jeho vlastní režii - zodpovědnou komponentou je SwordMovement. Ta operuje jako stavový automat. Tvůrce hry v editoru nakonfiguruje seznam stavů (potomci třídy SwordMovement.Submodule) a jejich mapování na stisknuté klávesy, SwordMovement pak dle vstupu od uživatele vybírá, který stav je aktivní - na tom jediném volá metodu OnFixedUpdate. V této metodě submodul provádí libovolnou vnitřní logiku (konkrétní příklady ukážeme v \ref{modesOfSwordMovementSubsection}) a nakonec na instanci SwordMovement zavolá metodu MoveSword(), které jako argument předá žádanou pozici meče. SwordMovement se následně postará o jeho plynulý přesun. 

Meč i šermíř jsou dětmi společného \textbf{kořenového objektu} - jeho starostí je, aby byly meč a šermíř řádně pospojované jeden s druhým a s objekty vnějšího světa. Konfigurujeme zde např. zdroj uživatelského vstupu (komponenta dědící z ISwordInput) či reference na kameru a prvky GUI (healthbar apod.).

Celkově by tento návrh měl poskytovat dobrou rozšiřitelnost logiky pro ovládání meče (stačí přidat nový SwordMovement.Submodule), implementace počítačem řízených šermířů by tomuto návrhu rovněž neměla činit problém (stačí vyměnit zdroj vstupu a odebrat reference na GUI).

\bigbreak

Druhou část kapitoly jsme věnovali zamyšlení nad rozhraním, skrze které bude probíhat komunikace mezi hrou a hráčem - předně jsme se zaměřili na ovládání meče (které, jak jsme nastínili v \ref{gamesWithMoreDirectControll}, představuje těžký problém).

Rozhodli jsme se pro \textbf{ovládání pomocí myši}. Nejprve jsme zkusili provádět mapování tak, že jsme dle polohy kurzoru z kamery stříleli paprsek a ten protínali s kulovou plochou - průnik odpovídal bodu, kterým má procházet čepel meče\footnote{Toto platí při použití základního submodulu pro sekání. Obecně bod průniku slouží jako vstup, ze kterého instance SwordMovement.Submodule může vydedukovat cokoliv uzná za vhodné.}. Toto v praxi fungovalo vcelku pěkně a tvářilo se jako pro hráče intuitivně uchopitelný formalizmus. Vyskytovaly se zde však okrajové případy, které např. pro hráče činily jednoduchým, aby sám sebe mečem probodnul.

Proto jsme systém zobecnili - místo jediné kulové plochy je možné jich definovat několik a mezi jednotlivými průniky se počítá vážený průměr. Touto metodou jsme schopni zachovat vše, co na předchozí variantě fungovalo dobře, ale zároveň je nám poskytnuta dodatečná flexibilita, která umožňuje ošetřit okrajové případy.

Dále jsme stanovili ovládání pro \textbf{pohyb hráčské postavy ve světě} - v této oblasti nám nic nebránilo použít klasické WASD, pouze jsme museli přidat klávesy QE pro rozhlížení, protože kurzor je již plně zaměstnán ovládáním meče.

\bigbreak
Nyní tedy máme vypracovaný návrh jak pro rozhraní popisující moduly naší práce, tak i pro rozhraní, skrze které budou tyto moduly komunikovat s uživatelem. Můžeme tedy přistoupit k implementaci.
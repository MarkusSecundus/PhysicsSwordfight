\chapter{Implementace}

\section{Implementace základních komponent}
\begin{itemize}
  \item \textbf{Šermíř}
    \begin{itemize}
      \item rigidbody (nekinematické)
    \end{itemize}
  \item \textbf{Meč}
    \begin{itemize}
      \item rigidbody (nekinematické)
      \item 
    \end{itemize}
\end{itemize}

\subsection{Moduly ovládání meče} \label{modesOfSwordMovementSubsection}
\begin{itemize}
  \item Co je modul z hlediska objektováho návrhu už čtenář ví, tady jenom popíšeme implementaci modulu pro sekání a modulu pro blokování
  \item \textbf{Abstrakce} 
    \begin{itemize}
      \item SwordMovement.Submodule
        \begin{itemize}
          \item samostatná abstraktní třída, nedědí z Unity.Object
          \item má metody jako OnUpdate, OnActivated, OnDeactivated apod. - za jejich volání nese zodpovědnost SwordMovement
          \item může volat metody na SwordMovementu (je do ní injectnuta instance rozrhraní ISwordMovement)
        \end{itemize}
      \item ISwordMovement
        \begin{itemize}
          \item Jednoduché rozhraní, exposuje jenom to, co submodul může potřebovat
          \item šikovné ho mít pro účely mockování v unit testech a taky protože takhle jsme schopní mezi SwordMovement a jeho komponenty nacpat dekorátor (kterej se tváří jako jediná aktivní komponenta, původní komponenty si ukradne pro sebe, sám se stará o správu toho, která je aktivní, a místo oficiálního SwordMovementu do nich injectne sebe) - takhle se dá např. elegantně nahrávat rozkazy pro pohyb meče (využijeme v \ref{knightEnemySubsection})
          \item věci, které exposuje: SwordDescriptor popisující meč, ISwordInput, Transform sword wieldera, metodu MoveSword()
        \end{itemize}
      \item Správu toho která komponenta je aktivní jsme enkapsulovali do třídy ScriptSubmodulesContainer -> dekorátor mezi SwordMovementem a jeho Submodulama se dá napsat celkem bez námahy
      \item Konfigurace submodulů z editoru - list párů klávesa-submodul ; submodule picker má dropdown, kde můžeme vybírat ze všech typů dědících ze SwordMovement.Submodule a pro vybraný typ se pak zobrazí defaultní picker - neskonalé díky: \href{https://github.com/lordconstant/SubclassPropertyDrawer}{lordconstant}
    \end{itemize}
  \item \textbf{Metoda SwordMovement.MoveSword()}
    \begin{itemize}
      \item vstupy: anchorPoint (poloha meče) + swordDirection (směr kam je namířený) + upDirection (směr nahoru - podle něj se počítá natočení kolem vlastní osy) + holdingForce (faktor síly držení)
      \item podle směru namíření a směru nahoru se nastaví cílová rotace mečového jointu
        \begin{itemize}
          \item stačí podle nich spočítat cílovou rotaci a tu nastavit jako targetRotation ConfigurableJointu (spočítat jí je ale netriviální problém - viz \ref{howToSetJointsTargetRotationSection})
        \end{itemize}
      \item nastavení polohy meče podle vyžádané cílové polohy...
        \begin{itemize}
          \item ConfigurableJoint podporuje stejně jako targetRotation i targetPosition - ta se ale při testování zdála nestabilní (čas od času meč odskočil 10 metrů vedle)
          \item ConfigurableJoint má property connectedAnchor - pozice místa kam je předmět jointem ukotvený, relativní vůči rigidbody ke kterému je joint ukotvený - jeho změnou můžeme efektivně mečem pohybovat
          \item potřeba nastavit Joint.autoConfigureConnectedAnchor = false
          \item chceme plynulý pohyb konzistentní rychlostí VS Joint.connectedAnchor se dá jenom natvrdo nastavit, neexistuje žádný targetConnectedAnchor 
          \item DOTween nejde použít (cílová pozice connectedAnchoru se potenciálně mění každý snímek - DOTween je stavěný na to, že cíl je známý od začátku a nemění se)
          \item řešení - vést si prostě target hodnotu a každý snímek connectedAnchor posunout o (target - currentConnectedAnchor)*deltaTime*speedFactor/*nastavitelný z editoru*/
          \item celou tuhle logiku jsme enkapsulovali do třídy RetargetableInterpolator - ta běží na pozadí jako korutina a jenom nastavujeme její target hodnotu
        \end{itemize}
      \item faktor síly držení
        \begin{itemize}
          \item důvod: někdy je správně defaultní síla, jakou hráč meč drží, někdy (modul blokování) ale např. potřebujeme, aby byl meč drženej tak silně, že rána druhého meče ho nedokáže srazit dolů
          \item na začátku si uložíme původní Joint.slerpDrive.positionSpring - nastavení faktoru síly držení znamená kolikanásobek téhle původní hodnoty se má začít používat
          \item plynulá změna - interpolujeme stejně jako Joint.connectedAnchor
          \item volitelný parametr - když není, bere se to jako by byla dodána hodnota 1 (-> 1-násobek původní síly)
        \end{itemize}
    \end{itemize}
  \item \textbf{Modul pro sekání:} 
    \begin{itemize}
      \item velmi jednoduchý
      \item má z editoru nastavitelný IRayIntersectable - prostě jenom vezme paprsek ze vstupu a intersectne ho
      \item když průnik není, nic neudělá
      \item když průnik je, nastaví hlášený střed koule jako handlePoint, lookDirection je (intersection.Value - intersection.Center)
      \item upVector je lookDirection.Cross(lastLookDirection) 
    \end{itemize}
  \item \textbf{Modul pro blokování:} 
    \begin{itemize}
      \item TODO: dopsat!
    \end{itemize}
\end{itemize}


\subsection{Animace šermíře}
\begin{itemize}
  \item detailní model šermíře.. klasický bone rig (SkinnedMeshRenderer vykresluje, vedle něj je hierarchie transformů - kosti), zahrnuje basic animaci dýchání vytvořenou v Blenderu
  \item není problém přidat víc animací, SwordsmanMovement pak bude muset komunikovat s animatorem a říkat mu co za animaci má hrát
  \item meč.. ovládaný fyzikálním systémem, může se hýbat dost libovolně VS ruce hráče fyzikálně simulované nejsou
  \item potřebujeme v postprocessu zařídit, aby to vypadalo, že ruce meč drží
  \item stanovili jsme 2 kontrolní body na meči - pozice držení pro pravou a levou ruku - uvedené ve SwordDescriptoru
  \item posledních pár verzí Unity podporuje package \href{https://docs.unity3d.com/Packages/com.unity.animation.rigging@1.3/manual/index.html}{Animation Rigging} - s ním je cca triviální tohle zařídit
  \item k detailnímu modelu šermíře jsme přidali procedurální Rig z tohoto package
  \item na každé z rukou je nastavená TwoBoneIK constraint (začíná UpperArm, končí Hand) + Multi-Aim Constraint (na kosti Hand)
  \item skript SwordsmanBodyProceduralAnimation - každý snímek nastaví target pozici IK constrainty na místo na handlu, co má držet; target Multi-Aimu dá někam do dáli aby ruka zaručeně ukazovala stejným směrem co paže 
  \item problém... nestabilní undefined behavior když je ruka kratší než vzdálenost k handlePointu
  \item řešení - vlastní constraint: RigToExtendSwordsmanArmsToReachTheSword - spočítá celkovou délku ruky a prodlouží ji (vynásobí lokální pozice jednotlivých kostí) tak, aby vždycky dosáhla na target pozici (s mírným přesahem, který se nastaví z editoru) - vypadá mírně creepy, ale je stabilní a dobře předává informaci pozorovateli
\end{itemize}


\subsection{Počítání zranění}
\begin{itemize}
  \item Cíl... být tak jednoduché jak jenom jde, ale myslet na rozšiřitelnost do budoucnosti
  \item \textbf{Damageable}
    \begin{itemize}
      \item float HP /*currentHP*/, MaxHP;
      \item poskytuje UnityEventy OnSpawn, OnUpdated, OnDamaged, OnHealed, OnDeath.
      \item metoda ChangeHP(float deltaHP) - řeší damageování i healování
      \item volitelně může celý gameobject automaticky zničit když zemře
    \end{itemize} 
  \item \textbf{AttackDeclaration}
      \begin{itemize}
        \item univerzální deskriptor co popisuje vykonaný útok
        \item zatím velmi jednoduchá, v případě potřeby možné do ní přidat další informace
        \item float Damage, informace (místo+normála) o bodu kde došlo ke zranění
      \end{itemize} 
  \item \textbf{IArmorPiece}
      \begin{itemize}
        \item rozhraní pro jakýkoliv hmotný objekt (obsahující collider), na který může být zaútočeno
        \item z collideru se kanonicky získává jako collider.GetComponentInParent<IArmorPiece>() - může být jeden obecný pro všechny collidery a ten overridovat potomci čistě jenom pro svoje vlastní collidery
        \item nese odkaz na damageable ke kterému patří
        \item metoda ProcessAttack(AttackDeclaration) - vyhodnoť provedený útok!, uber HP na svém Damageable
        \item poskytuje UnityEvent OnAttack
        \item \textbf{BasicArmorPiece} - konkrétní implementace - má DamageMultiplier a MinDamage (dmg pod hranicí je ignorováno), celkově se chová jak by člověk čekal
      \end{itemize} 
  \item \textbf{BasicImpactWeapon}
      \begin{itemize}
        \item jednoduchá zbraň, co útočí na jiný předmět tak, že s ním zkoliduje 
        \item parametry: DamageMultiplier, SecondsBetweenAttacks
        \item při kolizi (OnCollisionEnter) se podívá jestli druhý collider u sebe nemá IArmorPiece - když jo, tak na něm zavolá ProcessAttack()
        \item dmg počítá jako collision.impulse.magnitude*DamageMultiplier, bod zranění je podle collision.GetContact(0)
        \item metoda pro výpočet AttackDeclaration.. virtuální - možné nahradit sofistikovanější implementací
      \end{itemize} 
  
\end{itemize}


\section{Stabilita simulace}
\begin{itemize}
  \item 
\end{itemize}


\subsection{Jak nastavit cílovou rotaci jointu} \label{howToSetJointsTargetRotationSection}
\begin{itemize}
  \item cílová rotace configurable jointu se udává v souřadnicovém systému, co je relativní vůči jointu
\end{itemize}

\subsection{Ladění parametrů} \label{swordParameterTweaksSection}
\begin{itemize}
  \item 
\end{itemize}

\subsection{Kolize mečů} \label{swordCollisionsSection}
\begin{itemize}
  \item 
\end{itemize}


\section{Demo hra}
\begin{itemize}
  \item Pro testování a demonstraci funkčnosti našeho konceptu jsme vytvořili ukázkovou hru
  \item herní svět - aréna + okolní les
  \item PC - šermíř, může chodit po světě a používat libovolně meč
  \item v aréně lze bojovat s jednoduchými NPC nepřáteli
  \item všechny modely a textury byly vytvořené autorem této práce a vztahuje se na ně MIT licence jako na všechno ostatní
\end{itemize}

\subsection{Herní svět}
\begin{itemize}
  \item les jsou jenom pěkné kulisy
  \item V aréně jsou sloupy s čudlíkama, po jejichž stisknutí mečem se uvnitř arény spawne nepřítel
  \item několik druhů nepřátel: trénovací panák, mečotoč, rytíř (podrobně rozebereme v jejich vlastních sekcích)
\end{itemize}

\subsection{GUI}
\begin{itemize}
  \item všechno pomocí klasického gameobjectového UI
  \item PauseMenu.. naprostá klasika - root čeká na zmáčknutí Esc - pak nastaví Time.timeScale = 0 a enabluje svoje potomky
  \item DieScreen.. taky nic zajímavého - při spuštění tweenem přes obrazovku zobrazí hardcoded bloodstains sprite a "Press F to Restart" (reloadne scénu)
  \item HUD.. healthbar + bloodstains.. dvě drobné komponenty, nad nima kontroler - poskytuje callback, co se musí přidat do OnUpdate na nějakém Damageable
\end{itemize}


\subsection{Statičtí nepřátelé}
\begin{itemize}
  \item Nemohou se hýbat, stojí tam, kde byli spawnutí
  \item \textbf{Trénovací panák}
    \begin{itemize}
      \item Jenom stojí a bere damage dokud není zničený
    \end{itemize}
  \item \textbf{Mečotoč}
    \begin{itemize}
      \item Koule, co rotuje dokola na tyči (uchycené configurable jointem, který má nastavenou targetVelocity a angularDrive)
      \item Ke kouli je jointama připojených 1 nebo víc mečů - ty způsobují dmg úplně stejně jako šermířův meč
      \item Na jointu meče - vysoká connectedMassScale -> hráč může zachytit meč mečotoče o ten svůj a celý pohyb mečotoče tím zastavit, příp. tlačit proti směru rotace
      \item Při spawnu randomizován počet mečů, odkud kam se koule posunuje po tyči, a jakou má volnost rotace (- SwordmillRandomizer)
    \end{itemize}
  \item \textbf{IRandomizable}
  \begin{itemize}
    \item Libovolný skript, myšlenka je, že by měl při spawnu randomizovat parametry svého gameobjectu
    \item Spawnovací skript na entitě ihned po spawnu (tedy před zavoláním Start()) iteruje přes všechny IRandomizable ve všech potomcích a volá na nich metodu Randomize()
    \item Implementován např. pro randomizaci transformu (rotace, velikost trénovacího panáka, apod.), randomizaci HP, randomizaci mečotoče
    \item Ten samý systém je použitý i pro náhodou generaci palisády, co ohraničuje arénu
  \end{itemize}
\end{itemize}


\subsection{Rytíř} \label{knightEnemySubsection}
\begin{itemize}
  \item 
\end{itemize}


\section{Shrnutí}

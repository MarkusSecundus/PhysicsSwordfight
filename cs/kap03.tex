\chapter{Technické základy}

V této kapitole čtenáře seznámíme s herním enginem Unity \cite{Unity} do míry potřebné k pochopení zbytku práce. Stručně nastíníme architekturu, kterou pro tvorbu herních systémů tento engine podporuje, a zmíníme některé jeho vestavěné knihovny - především se podrobně zaměříme na integrovaný fyzikální subsystém.


\section{Herní engine Unity} \label{unityEngineIntroSection}

První verze enginu Unity byla představena v roce 2005. Od té doby bylo vydáno mnoho verzí, přidáno mnoho funkcionalit a mnoho dalších prohlášeno za zastaralé. Tvůrcům se dařilo držet krok s dobou, v dnešní době jde o velmi vyspělý a moderní engine, který uživatelům nabízí \textbf{široký ekosystém nástrojů}, ať už jde o integrované komponenty, nebo balíčky třetích stran. 

Jednou z jeho velkých sil je \textbf{všestrannost} - zvládá stejně dobře 2D i 3D hry, výsledný spustitelný produkt lze vyexportovat pro širokou škálu platforem - desktopové, mobilní, konzole i web.

Pro programování herní logiky je zde podporován jazyk C\#. Jako runtime je dosud používáno postarší \textbf{Mono}, které umožňuje nanejvýše \textbf{C\# verze 9} s pár drobnostmi nepodporovanými, avšak stále jde o vcelku moderní jazyk, který programátorovi umožňuje pohodlnou práci. Interakce s knihovnami třetích stran, které závisejí na některých součástech moderního frameworku .NET, může činit problémy, avšak typicky nejde o nepřekonatelnou překážku.

Jde o \textbf{komerční produkt s uzavřenou licencí}, avšak cenová politika je více než přívětivá. Pro nekomerční projekty a projekty nepřesahující určitou hranici celkového ročního zisku je \textbf{použití enginu zcela zdarma}. Právní úprava nijak nebrání vydávání samostatných projektů v enginu tvořených pod opensource licencí. Dokumentace není celkově na špatné úrovni a těch pár míst, kde pokulhává, vynahrazují velmi živá komunitní fóra.
\bigbreak
V této kapitole si představíme základní principy použití enginu v rozsahu nutném pro vysvětlení zbytku práce. Jejich kompletnější popis čtenář najde v oficielní dokumentaci \cite{Unity}. 

\subsection{Herní objekty a komponenty}

\subsubsection*{Scéna}
Základním prvkem je \textbf{scéna} - ta odpovídá jedné oblasti ve hře. Scéna může být aktivní vždy jen jedna, hráč mezi nimi přechází.

\subsubsection*{Herní objekt}
Scéna je popsána hierarchií \textbf{herních objektů} (třída UnityEngine.GameObject). Každý herní objekt je definován svou pozicí v hierarchii (svým otcem), transformační maticí (udává pozici v herním světě) a jménem\footnote{Jméno slouží pro dokumentační a debugovací účely.} a najdeme v něm (volitelně prázdný) list dodatečných komponent.

\subsubsection*{Komponenty}
Komponenty jsou základními modulárními stavebními prvky, ze kterých skládáme herní logiku. Herní engine nám poskytuje velké množství již hotových - např. jednu, skrze kterou lze definovat grafickou reprezentaci objektu, další, jež nese zodpovědnost za vykreslení této reprezentace - takto by bylo možné pokračovat velmi dlouho. Uživatel může vytvořit vlastní typ komponenty tak, že ve skriptu definuje třídu dědící z UnityEngine.MonoBehavior. Následně mu již nic nebrání vybrat si v editoru herní objekt a novou instanci komponenty (její jméno odpovídá jménu třídy) do něj přidat.

Každá komponenta může nést data a herní logiku, ty jsou definovány jednoduše skrze instanční proměnné a metody.  

\subsubsection*{Transform}

Speciální komponentou je UnityEngine.Transform. Tu nalezneme na každém herním objektu, reprezentuje jeho \textbf{transformační matici} a \textbf{pozici v objektové hierarchii}. Každý objekt má vlastní matici, která definuje jeho polohu, rotaci a škálování - lokálně vůči otci. Celková transformace objektu je určena vynásobením této matice se součinem matic všech předků.

\subsubsection*{Serializace}

Při práci na hře často narazíme na situaci, kdy by bylo užitečné moci nastavit část dat, které komponenta nese, ručně z editoru. Engine nám toto umožní.

Jakoukoliv proměnnou, která je deklarovaná jako public či anotovaná atributem [UnityEngine.SerializeField], se editor pokusí poskytnout k editaci.
\begin{itemize}
    \item Primitivní a vestavěné typy zpravidla nečiní problém.
    \item Pro typy dědící z UnityEngine.Object je poskytnuto pole, do kterého je možné přetáhnout jakýkoliv objekt ze scény či prefab.
    \item Uživatelsky definované třídy musí být anotovány jako [System.Serializable] - jejich editor pak sestává rekurzivně z políček odpovídajících jejich proměnným, instance je vytvořena automaticky skrze výchozí konstruktor.
    \item Proměnná nesmí být typu rozhranní, až do nedávna nebyly podporovány ani typy s generickým parametrem.
    \item Z datových struktur jsou podporovány pouze obyčejné pole a System.Collections.Generic.List<>.
\end{itemize}
Dalším omezením je, že musí jít vždy o proměnné - properties podporovány nejsou.

Tato omezení - především nemožnost používat interfacy a properties\footnote{Nepodporu složitějších datových struktur lze napravit použitím pokročilých technik pro vytváření vlastních editorových oken. Nepodpora generik pak činí problém spíše jen u sealed typů a structů, ze kterých není možné odvodit negenerického potomka.} - mohou programátorovi značně ztížit snahy o dodržování dobrých praktik objektového programování.

Důvodem je, že tato úprava polí v editoru je specielním případem použití \textbf{standardního serializačního subsystému} enginu Unity. Na ten narazíme kdekoliv, kde je třeba interně ukládat herní stav do podoby, ze které bude možné jej později rekonstruovat. Mimo jiné je rovněž zodpovědný za to, aby ve finální sestavené verzi hry bylo načítání scény pro hráče co nejrychlejší. Je tedy jen přirozené, že je koncipován především pro co možná nejvyšší výkon - z čehož plynou výše zmíněná omezení.

\subsubsection*{Prefaby}
Standardní serializační systém však programátorovi přináší i mnoho výhod. Jeho nápomocí nám je umožněno jednoduše přetáhnout herní objekt z objektové hierarchie do souborového systému a vytvořit z něj tzv. \textbf{prefab}. Takto osamostatněný objekt můžeme následně referovat libovolněkrát v libovolné scéně a systém se postará, aby veškeré změny, které byly provedeny přímo na prefabu, byly přeneseny do jednotlivých instancí, zatímco změny oproti prefabu, kterých jsme se dopustili na konkrétní instanci, zůstanou zachovány. Rovněž je možné vytvořit \textbf{variantu prefabu} - samostatný prefab, který se odkazuje na jiný prefab jakožto svou předlohu a vůči ní přibaluje nějaké změny. 

Jak vidíme, jde o mocný nástroj umožňující organizaci herních objektů podobně flexibilním způsobem, jaký nabízí dědičnost v oblasti objektového programování. 

\subsubsection*{Komunikace mezi komponentami} \label{communicationBetweenComponentsSubsubsection}

Jakákoliv trochu komplexnější herní logika se neobejde bez vzájemné komunikace mezi komponentami. Unity nám k tomuto účelu nabízí hned několik základních cest.

První z nich je zkrátka na instanci druhé komponenty \textbf{zavolat metodu, kterou chceme}. Výhodou je, že metoda může mít libovolné množství argumentů, být generická, ... celkově je možné využívat plně možností, které jazyk C\# poskytuje. Nevýhodou je, že musíme mít přímý odkaz na instanci, na které volání uskutečňujeme.

Druhou možností je \textbf{UnityEvent}. Jde o obdobu klasických C\# delegátů, která však podporuje serializaci a je ji tedy možné konfigurovat z editoru. S její pomocí komponenta může definovat callbacky, do kterých je následně v editoru zaregistrováno libovolné množství posluchačských metod patřících ostatním komponentám. Zavoláním metody Invoke() na instanci UnityEvent jsou následně zavolány všechny posluchačské metody, jedna po druhé.

Poslední možností je \textbf{posílání zpráv}. Tento mechanismus je hojně používán pro komunikaci mezi komponentami a systémem. Princip je jednodchý: na libovolném herním objektu je možné zavolat metodu SendMessage() - jejím parametrem je jméno metody, volitelně ještě libovolný objekt jako argument. Systém projde všechny komponenty náležící danému objektu a pokud nějaký z nich definuje (jedno zda veřejnou či privátní) metodu, jejíž hlavička odpovídá jménu a typu argumentu, jež jsme metodě SendMessage předali, všechny takovéto metody budou jedna po druhé zavolány.

\subsubsection*{Jak hledat komponenty}

V mnoha případech potřebujeme s instancí jiné komponenty komunikovat přímo. Jakým způsobem lze tedy odkaz na ni získat?

Nejjednodušší možností je na naší komponentě zavést serializovatelnou proměnnou, do které odkaz na druhou komponentu doplníme v editoru. 

Pokud tato možnost nepřipadá v úvahu, či je komponent mnoho a přetahovat všechny by bylo přespříliš úmorné, Unity nabízí mnoho cest, jak scénu prohledávat. Mezi základní patří:

\begin{itemize}
    \item \textbf{gameObject.GetComponent<TComponent>()} - Voláme na konkrétní instanci herního objektu. Vrátí první komponentu typu TComponent, jež se v objektu nachází, popř. null. TComponent může být konkrétní typ komponenty, rovněž to však může být rozhraní. Existuje také varianta GetComponent\underline{s}<TComponent>(), která iteruje všechny takové komponenty, pokud jich je více. Také GetComponent(s)InParent() a GetComponent(s)InChildren(), které prohledávají celou objektovou hierarchii směrem od objektu nahoru/dolu.
    \item \textbf{UnityEngine.Object.FindFirstObjectByType<TObject>()} - Statická metoda. Podobné chování jako GetComponent, avšak prohledává celou aktivní scénu. 
    \item \textbf{UnityEngine.GameObject.FindByTag()} - Rovněž prohledává celou scénu. Pro každý herní objekt je možné v editoru nastavit specielní poznávací symbol - tag - podle něj zde vyhledáváme. Vrací odkaz na herní objekt, na něm typicky ještě bude nutné zavolat GetComponent. Toto je obecně doporučovaný způsob, jak získávat odkaz na singletony.
\end{itemize}

Je však třeba podotknout, že všechny tyto možnosti zpravidla vykonávají nějakou formu lineárního hledání a nejsou tedy zcela efektivní. Velmi doporučované je provádět hledání pokud možno jen jednou při aktivaci naší komponenty, a jeho výsledek si "nakešovat" do proměnné.

\subsection{Herní smyčka}

Typická videohra běží v \textbf{nekonečné smyčce}. Jsou načteny vstupy, provedena aktualizace herního stavu, následně vykreslena grafika - jakmile je hotovo, opakujeme. 

V Unity je herní smyčka plně v režii systému, programátor může ve svých skriptech pouze \textbf{poslouchat na události}, které v jejím průběhu nastanou. Ty jsou mu typicky komunikovány pomocí výše popsaného systému posílání zpráv (viz \ref{communicationBetweenComponentsSubsubsection}).
Typickými takovými zprávami jsou:

\begin{itemize}
    \item \textbf{Update()} - Volána jednou za každý snímek. Zde by měla být updatována herní logika. Čas uplynulý od minulého snímku není předáván jako argument, nýbrž ho lze vyčíst ze statické proměnné UnityEngine.Time.deltaTime.
    \item \textbf{Start()} - Volána jednou za život objektu, těsně před tím, než je zavolán jeho první Update(). Zde by typicky mělo probíhat hledání dalších komponent a podobné inicializační operace.
    \item \textbf{Awake()} - Volána okamžitě po vytvoření objektu, tedy dříve než Start. Některé další zprávy mají okrajové případy, ve kterých rovněž mohou být zavolány dříve než Start - pokud to hrozí, je třeba provést inicializaci zde.
    \item \textbf{OnDestroy()} - Volána při zničení komponenty. Zde může uvolnit držené zdroje.
\end{itemize}
Zajímavou vlastností je, že komponenta může být nastavena jako \textbf{neaktivní} - v takovém případě nedostává zprávy Update a volání Start je odloženo. Awake a OnDestroy však stále volány jsou.

Rovněž je užitečné vědět, že veškeré zprávy herní smyčky jsou volány \textbf{sekvenčně na hlavním vlákně}. Multithreading v Unity nalezneme pouze na specifických místech, a na těch si tvůrci dali záležet, aby byl uživatel velmi důrazně varován.


\subsection{Knihovny}

Kromě standardní knihovny jazyka C\# poskytuje Unity \textbf{mnoho dalších knihoven} nabízejících funkcionalitu užitečnou specificky při tvorbě videoher.

Samozřejmě zde najdeme mnoho nástrojů pro pokročilou \textbf{interakci s hierarchií herních objektů} - ničit objekty či vytvářet nové za běhu není problém. 

Dále zde najdeme například široký výběr \textbf{matematických primitiv} - vektory (2D a 3D) a matice umožňující provádět základní operace známé z lineární algebry a mnoho typů reprezentujících další geometrické objekty jako přímky či roviny.

Velkými tématy pro videohry jsou jak známo například \textbf{vykreslování grafiky} s pomocí GPU, \textbf{animace}, či \textbf{navigace herních postav terénem}. Pro každou z těchto oblastí a mnoho dalších disponuje Unity dedikovaným subsystémem. O šířce jeho záběru se lze přesvědčit v oficielní dokumentaci \cite{Unity}.

\section{Fyzikální subsystém enginu Unity}

Jedním z těchto subsystémů, který budeme napříč naší prací extenzivně využívat, je ten pro fyzikální simulaci. Jeho náplní práce je vypočítávat pohyby a síly působící mezi objekty herní scény, způsobem velmi podobným tomu, jaký známe z klasické středoškolské kinematiky a dynamiky pevného tělesa. Unity poskytuje takové systémy dokonce dva\footnote{Více když neopomeneme Unity DOTS.} - jeden operující v 3D prostoru, druhý pro 2D. Oba jsou samostatnými celky a nesdílejí žádné společné součásti. Ve zbytku práce budeme fyzikálním subsystémem automaticky myslet ten pro 3D.   

Užitečnou informací je, že tento subsystém je pouze tenkým rozhraním pro podmnožinu funkcionality backendu, kterým je Nvidia PhysX \cite{PhysX}. Dokumentaci Nvidie \cite{PhysX} lze tedy doporučit k pročtení komukoliv, kdo chce získat hlubší pochopení celkového fungování systému, než jaké nabízí oficielní dokumentace Unity.

\subsection{Základy}

Pro zaručení větší stability je pravidlem, že by fyzikální simulace měla být aktualizována ve fixních časových intervalech. Unity tedy pro tyto účely nabízí \textbf{fixní herní smyčku}, která běží (rovněž v hlavním vlákně) paralelně s tou klasickou. Ve skriptu můžeme poslouchat na zprávu FixedUpdate() - ta je zavolána každý fixní snímek, těsně před vykonáním kroku fyzikální simulace. 

Subsystém si vede vlastní interní reprezentaci celé scény. Nad tou vykonává veškeré výpočty, až po dokončení celého kroku simulace podle ní updatuje transformy objektů ve scéně. 

\subsection{Rigidbody}

Základní komponentou je Rigidbody. Jeho přidáním získá herní objekt schopnost být ovlivňován silami a působit silami na ostatní objekty.

Přímo na této komponentě můžeme nastavit jeho základní parametry jako je váha, poloha těžiště, zda na něj má působit gravitace či zda je \textbf{kinematické}.

\textbf{Nekinematické} rigidbody má pohyb plně ovládaný fyzikální simulací. Každý fyzikální snímek je systémem pohnuto dle své aktuální rychlosti (rigidbody.velocity), tu mohou ovlivňovat síly, které na něj působí - vyvolané buď gravitací, kolizemi, nebo aplikací ze skriptu (rigidbody.AddForce(), rigidbody.AddTorque()).

\textbf{Kinematické} oproti tomu může působit (kolizními) silami na ostatní objekty, avšak samo fyzikálním systémem ovládané není - jeho pohyb je plně v režii programátora, který ho může vykonávat klasicky updatováním komponenty Transform.

Mezi těmito dvěma stavy \textbf{lze přepínat} jednoduše úpravou flagu (rigidbody.isKinematic). Nečiní tedy problém mít např. meč, který je plně fyzikálně simulovaný, ale při sesílání kouzla se přepne a přehraje předpřipravenou animaci, či naopak postavu, která je ovládána animacemi, ale v okamžiku smrti se změní ve fyzikálně simulovanou ragdoll.

\subsection{Collider}

Collidery jsou komponenty, které určují pro účely fyzikálního systému tvar objektu a umožňují mu kolidovat s ostatními objekty. 

V komplikovanější scéně jich často v jednom okamžiku najdeme vyšší stovky až tisíce. Proto je jedním z nejdůležitějších úkolů každého fyzikálního systému zaručit, aby detekce kolizí probíhala \textbf{co nejefektivněji} a byl tím pádem umožněn běh hry v reálném čase.

Jedním z prostředků, které pomáhají toho dosáhnout, je použití \textbf{primitivních tvarů} namísto colliderů přesně odpovídajících grafickému meshi objektu\footnote{Collidery definované meshem do jisté míry podporovány jsou, ale nesou mnohá omezení. Jejich použití má smysl převážně pro statický terén herního světa a zde se jimi nebudeme zaobírat.}. Unity nám nabízí tři - \textbf{krychli, kouli a kapsli}\footnote{válec s polokoulemi na obou koncích} - na objekt je umístíme přidáním odpovídající komponenty (BoxCollider, SphereCollider, CapsuleCollider). Komplexnějších tvarů dosahujeme skládáním více colliderů dohromady\footnote{Skutečně jde o jedinou možnost. Bystrý čtenář by mohl očekávat, že šikovným použitím transformační matice na herním objektu, kde se collider nalézá, by neměl být problém např. z BoxCollideru vytvořit rovnoběžnostěn. V dokumentaci se však lze dočíst, že podobné transformace ústí v nedefinované chování.}. Tím lze samozřejmě vytvořit pouze hrubou aproximaci skutečného tvaru objektu, v praxi se to však ukazuje jako naprosto dostatečné - při umném rozmístění hráčský zážitek obvykle nijak netrpí.

\textbf{Tvar rigidbody} stanovíme tak, že umístíme libovolné množství colliderů do objektu, kde je komponenta rigidbody definována, či libovolně do jeho potomků. Všechny tyto collidery jsou následně považovány dohromady za jeden kompozit, který popisuje celkový tvar rigidbody. 

\textbf{Statickým} colliderem nazveme takový, který není součástí hierarchie žádného rigidbody. Takový collider je schopen kolidovat s rigidbodies a sloužit pro ně jako překážka. Je považován za pevnou součást scény a jeho transform by měl po celé trvání hry zůstat stejný (pohyb může ústit v nedefinované chování). Chceme-li collider s chováním statického, kterým však můžeme bez obav pohybovat, umístíme jej do kinematického rigidbody. Statické a kinematické collidery přirozeně vzájemně nekolidují.

Jemnější kontrolu nad tím, \textbf{co s čím může kolidovat}, nám poskytují tzv. \textbf{Layers}. Jde o pojmenované skupiny, kterých může být definováno nanejvýš 32 a nastavují se jako vlastnost herního objektu (gameObject.layer). V globálním nastavení herního projektu lze následně pro konkrétní páry vrstev kolize zakázat - takové dva objekty následně projdou bez reakce skrze sebe, kolize nebude ani detekována. Pro jemnější kontrolu je každý collider vybaven whitelistem a blacklistem vrstev, pomocí kterého lze globální nastavení přepsat. Ještě jemnější kontroly pak je možné dosáhnout ze skriptu - pomocí statické metody UnityEngine.Physics.IgnoreCollision() lze zakázat kolize pro konkrétní pár colliderů\footnote{Takto je však možné pouze kolize selektivně zakázat, nikoliv povolit. IgnoreCollision(a, b, false) pro a, b na vrstvách, které se ignorují, stále zanechá tento pár neschopný kolize.}.

Často potřebujeme pouze detekovat, že ke kolizi dvou objektů došlo, aniž bychom z toho vyvozovali nějaké fyzikální implikace - např. pokud fotbalový míč vstoupí do vnitřní části branky, chceme započítat gól, avšak rozhodně nechceme, aby vnitřek branky sám míči jakkoliv bránil ve vstupu. Pro tyto účely slouží flag \textbf{collider.isTrigger}. Po jeho zaškrtnutí collider přestane na kolidující objekty působit silami bránícími v průniku, stále však budou kolize detekovány.

Každá probíhající kolize je kolidujícímu hernímu objektu komunikována \textbf{posíláním zpráv} OnCollisionEnter, OnCollisionStay a OnCollisionExit. V případě trigger collideru jsou posílány obdobné zprávy začínající na OnTrigger - rozdíl mezi nimi je ten, že argument OnCollision obsahuje podrobné informace o bodech dotyku a silách použitých k rozřešení, OnTrigger poskytne pouze druhý collider. 

Velmi důležitým aspektem tohoto chování, který oficielní dokumentace zcela zamlčuje, je, že v případě Rigidbody jsou OnCollision zprávy poslány pouze do kořenového herního objektu - i v případě, že konkrétní kolidující collider se nachází v jednom z jeho potomků. OnTrigger zprávy jsou pak poslány vždy jak do kořenu, tak do konkrétního triggerovaného objektu. Do žádného z dalších objektů v hierarchii však stále ne. Toto má velký význam v kontextu toho, že ani OnCollision, ani OnTrigger svým argumentem neposkytují odkaz na konkrétní collider, jehož prostřednictví naše rigidbody zkolidovalo (pouze na ten, který zkolidoval s námi) - dozvědět se spolehlivě\footnote{Nespolehlivou cestou je např. collision.GetContact(0).thisCollider. Dle dokumentace máme mít zaručeno, že collision vždy bude obsahovat alespoň jeden kontakt. To však platí s výjimkou OnCollisionExit a ve skutečnosti se tak často neděje ani v ostatních zprávách.}, který to byl, je tedy, především pro zprávu OnCollision, velmi netriviální problém, který může mít dalekosáhlé následky pro některé aspekty architektury našeho systému.

Poslední důležitou problematikou, kterou letmo zmíníme, jsou metody \textbf{detekce kolizí}. Výchozí je detekce diskrétní - ta zkrátka každý krok simulace projde celou scénu a provede testy, zda aktuálně nějaké objekty mají neprázdný průnik. To je rychlé a v mnoha případech funguje dostatečně dobře. Problém však činí rychle letící či malé objekty - klasickým případem je projektil vystřelený z palné zbraně. U toho se může stát, že v jednom snímku je na jedné straně stěny, ve snímku následujícím již zcela na straně druhé, aniž by jakákoliv kolize byla detekována - projektil tzv. \textbf{protuneloval}. Řešení tohoto problému nabízí \textbf{spojitá detekce kolizí} - ta propočítává celkovou dráhu objektu v průběhu času mezi snímky a ústí tedy v horší výkon. Konkrétní implementace, které Unity nabízí, budou velmi relevantní pro \ref{swordCollisionsSection} a podrobně je tedy představíme tam.

\subsection{Joints}


\begin{itemize}
    \item (velmi stručně) co je constraint solver a jaký používá Unity
    \item strohý výčet jmen jointů a že všechny jsou to speciální případ Configurable Jointu (neboli D6 jointu jak ho zná PhysX)
    \item představení Configurable Jointu
    \item anchor, connectedAnchor
    \item locked/limited/free pro každý degree of freedom
    \item primary, secondary, tertiary axis, vůči čemu jsou rotace relativní (podrobněji rozebereme v \ref{howToSetJointsTargetRotationSection})
    \item positional\&angular drive - síly (spring VS damper), cílová pozice (nestabilní, alternativa nastavení connectedAnchoru) a rotace, RotationDriveMode (Slerp VS X+YZ - jenom letmo zmínit, "Slerp se choval pěkně a tak jsme ho vybrali"), Target (angular) velocity
    \item massScale VS connectedMassScale
    \item stabilita, flag EnablePreprocessing, projekce (projection mode+distance+angle)
\end{itemize}


\subsection{Stabilita simulace}
\begin{itemize}
    \item všechno to je jenom hodně hrubá aproximace, priorita je aby to běželo rychle a dalo se rozběhnout na GPU
    \item postup simulace po krocích, tunelování
    \item přesnost IEEE floatu - hodně malé/velké objekty, zaokrouhlovací chyba
    \item constraint solver, nesplnitelné constrainty, iterativní metody
    \item to, že collidery neodpovídají meshům, taky nepřidává přesnosti
    \item ladění - parametry fixedFrameDuration, iterationCount, který constraint solver se používá apod.
    \item zmínit vestavěný Physics Debugger
\end{itemize}


\section{Shrnutí}

Unity je velmi vyspělý engine, který za sebou má desetiletí vývoje a s jeho pomocí bylo vytvořeno mnoho komerčně úspěšných her. Pro svou velmi přívětivou cenovou politiku a možnost kompilovat hry pro širokou škálu platforem od konzolí po mobilní zařízení se stal \textbf{oblíbeným nástrojem začínajících vývojářů a malých týmů}. Uživateli poskytuje mnoho nástrojů a knihoven, od editoru scény po subsystém pro navigaci entit v herním světě. Libovolnou další funkcionalitu lze přidat pomocí skriptů v jazyce C\#. 

Herní scéna je hierarchií objektů - každý z nich je definován svým předkem, jménem, transformační maticí a listem komponent. Komponenty jsou základním stavebním prvkem, kterým dodáváme objektům jejich vlastnosti - např. schopnost mít vizuální reprezentaci, schopnost kolidovat s okolními objekty. Unity poskytuje mnoho předpřipravených komponent, uživatel může definovat vlastní jako skripty dědící z třídy MonoBehavior.

Jednou ze zajímavých skupin komponent jsou ty poskytnuté vestavěným \textbf{fyzikálním sybsystémem}. Jejich prostřednictvím je uživateli poskytnuto rozhraní odpovídající velké podmnožině systému Nvidia PhysX \cite{PhysX}. 

Základem je komponenta Rigidbody - jejím přidáním se z objektu stává fyzikální entita, na kterou lze působit silami. Chceme-li fyzikálnímu objektu umožnit kolidovat s dalšími objekty, přidáme mu jednu nebo více komponent typu Collider. Pro vytváření složitějších vztahů a závislostí mezi jednotlivými fyzikálními tělesy slouží Jointy - s jejich pomocí můžeme vytvořit například dveře otevíratelné v pantech či realisticky se chovající kovový řetěz.

Fyzikální simulace je velmi mocný nástroj, nevytváří však věrný obraz reality. Na mnoha místech narážíme na numerickou stabilitu a také zkrátka na fakt, že hlavní prioritou nikdy nebyla dokonalá přesnost, nýbrž schopnost vyhodnocení v reálném čase.

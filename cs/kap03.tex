\chapter{Technické základy}

V této kapitole čtenáře seznámíme s herním enginem Unity \cite{Unity} do míry potřebné k pochopení zbytku práce. Stručně nastíníme architekturu, kterou pro tvorbu herních systémů tento engine podporuje, a zmíníme některé jeho vestavěné knihovny - především se podrobně zaměříme na integrovaný fyzikální subsystém.


\section{Herní engine Unity} \label{unityEngineIntroSection}

První verze enginu Unity byla vydána v roce 2005. Od té doby bylo vydáno mnoho verzí, přidáno mnoho funkcionalit a mnoho dalších prohlášeno za zastaralé. Tvůrcům se dařilo držet krok s dobou, v dnešní době jde o velmi vyspělý a moderní engine, který uživatelům nabízí \textbf{široký ekosystém nástrojů}, ať už jde o integrované komponenty, nebo balíčky třetích stran. 

Jednou z jeho velkých sil je \textbf{všestrannost} - zvládá stejně dobře 2D i 3D hry, výsledný spustitelný produkt lze vyexportovat pro širokou škálu platforem - desktopové, mobilní, konzole i web.

Pro programování herní logiky je zde podporován jazyk C\#. Jako runtime je dosud používáno postarší \textbf{Mono}, které umožňuje nanejvýše \textbf{C\# verze 9} s pár drobnostmi nepodporovanými, avšak stále jde o vcelku moderní jazyk, který programátorovi umožňuje pohodlnou práci. Interakce s knihovnami třetích stran, které závisejí na některých součástech moderního frameworku .NET, může činit problémy, avšak typicky nejde o nepřekonatelnou překážku.

Jde o \textbf{komerční produkt s uzavřenou licencí}, avšak cenová politika je více než přívětivá. Pro nekomerční projekty a projekty nepřesahující určitou hranici celkového ročního zisku je \textbf{použití enginu zcela zdarma}. Právní úprava nijak nebrání vydávání samostatných projektů v enginu tvořených pod opensource licencí. Dokumentace není celkově na špatné úrovni a těch pár míst, kde pokulhává, vynahrazují velmi živá komunitní fóra.
\bigbreak
V této kapitole si představíme základní principy použití enginu v rozsahu nutném pro vysvětlení zbytku práce. Jejich kompletnější popis čtenář najde v oficielní dokumentaci \cite{Unity}. 

\subsection{Herní objekty a komponenty}
\begin{itemize}
    \item scéna - hierarchie gameobjectů
    \item gameobject - kontejner do kterého se naházejí komponenty
    \item komponenta - modul poskytující objektu nějaký kousek funkcionality; builtin, nebo to je uživatelsky definovaná třída; může obsahovat nějaká data (nastavitelná v editoru) a nějakou herní logiku (která příp. zahrnuje komunikaci s ostatními komponentami a gameobjecty)
    \item serializace - z editoru se dají editovat public/[SerializeField] fieldy ; nekompatibilní s properties, interfacama a jinýma datovýma strukturama než pole/list - omezující když chce člověk používat klasické dobré OOP practices  
    \item z herního objektu se dá vytvořit prefab
\end{itemize}


\subsection{Posílání zpráv}
\begin{itemize}
    \item srovnání VS UnityEvent VS C\# delegáti 
\end{itemize}

\subsection{Herní smyčka}
\begin{itemize}
    \item zpráva Update, deltaTime
    \item všechno probíhá sekvenčně na main threadu
\end{itemize}

\subsection{Základní knihovny}
\begin{itemize}
    \item (vše pouze zmínit že existuje)
    \item matematická primitiva - Vector3, Ray, matice, apod.
    \item instanciace gameobjectů a komponent za runtimu
    \item Vykreslování grafiky
    \item NavMesh
    \item extrémně moc dalších věcí
\end{itemize}


\section{Fyzikální subsystém enginu Unity}

\subsection{Představení}
\begin{itemize}
    \item zjednodušená dynamika a kinematika pevného tělesa
    \item je to vlastní Uniťácké API postavené nad backendem nVidia PhysX, ale poskytuje jenom podmnožinu kompletní PhysX funkcionality
    \item uvést reference na Unity a na PhysX dokumentaci\footnote{Chci mít odděleně referenci na Unity a na Unity-docs, nebo jenom Unity a nechat ho aby url neukazovalo na main page ale na docs?}
    \item zmínit že Unity má taky 2D Physics, co jsou úplně odděleně a za backend maj Box2D 
    \item vede si vlastní reprezentaci celé scény, při počítání vychází jenom z ní, před a po každém kroku se provede synchronizace s herním světem (updatnou transformy apod.)
    \item FixedUpdate
\end{itemize}


\subsection{Rigidbody}
\begin{itemize}
    \item non-kinematic VS kinematic
    \item properties (mass, center-of-mass+inertia-tensor, (angular) drag, axis-lock,...)
    \item jak se chová vůči transform-hierarchii
          \begin{itemize}
            \item fyzika používá globální souřadnice objektů
            \item collidery v potomcích patří otcovskému rigidbody
            \item rigidbody uvnitř rigidbody -> undefined behavior
          \end{itemize}
\end{itemize}

\subsection{Colliders}
\begin{itemize}
    \item zmínit že to je nejvíc základní a používaná funkcionalita physics systému, kvůli který ho spousta her includuje i když nepoužívají žádný non-kinematic rigidbodies a tak.  
    \item primitivní tvary, jejich skládání, nefunkčnost obecné maticové deformace (vždy zachovává kvádrovost, kulovost, kapsulovost)
    \item NEodpovídá(!) přesně tvaru meshe a v tom je pointa, ale když se umístěj šikovně, nijak to nekazí hráčský zážitek
    \item (letmo zmínit) mesh collidery existují - ale je u nich dost omezení, mají smysl jenom na terén apod.
    \item statické vs dynamické collidery (úplně samostatné / kinematic / non-kinematic) - co s čím koliduje a jak se chovaj když se pohybujou (pohyblivé collidery by měly být na nějakém (klidně kinematickém) rigidbody)
    \item trigger collidery
    \item Layers - co s čím koliduje; slouží i pro jinou funkcionalitu naprosto nesouvisející s fyzikou(!) ( další problémy rozebereme v \ref{swordCollisionsSection})
    \item zpráva OnCollisionXx / OnTriggerXx
    \item discrete VS continuous collision detection (jenom že existuje, podrobněji v \ref{swordCollisionsSection})
\end{itemize}

\subsection{Joints}
\begin{itemize}
    \item (velmi stručně) co je constraint solver a jaký používá Unity
    \item strohý výčet jmen jointů a že všechny jsou to speciální případ Configurable Jointu (neboli D6 jointu jak ho zná PhysX)
    \item představení Configurable Jointu
    \item anchor, connectedAnchor
    \item locked/limited/free pro každý degree of freedom
    \item primary, secondary, tertiary axis, vůči čemu jsou rotace relativní (podrobněji rozebereme v \ref{howToSetJointsTargetRotationSection})
    \item positional\&angular drive - síly (spring VS damper), cílová pozice (nestabilní, alternativa nastavení connectedAnchoru) a rotace, RotationDriveMode (Slerp VS X+YZ - jenom letmo zmínit, "Slerp se choval pěkně a tak jsme ho vybrali"), Target (angular) velocity
    \item massScale VS connectedMassScale
    \item stabilita, flag EnablePreprocessing, projekce (projection mode+distance+angle)
\end{itemize}


\subsection{Stabilita simulace}
\begin{itemize}
    \item všechno to je jenom hodně hrubá aproximace, priorita je aby to běželo rychle a dalo se rozběhnout na GPU
    \item postup simulace po krocích, tunelování
    \item přesnost IEEE floatu - hodně malé/velké objekty, zaokrouhlovací chyba
    \item constraint solver, nesplnitelné constrainty, iterativní metody
    \item to, že collidery neodpovídají meshům, taky nepřidává přesnosti
    \item ladění - parametry fixedFrameDuration, iterationCount, který constraint solver se používá apod.
    \item zmínit vestavěný Physics Debugger
\end{itemize}


\section{Shrnutí}

Unity je velmi vyspělý engine, který za sebou má desetiletí vývoje a s jeho pomocí bylo vytvořeno mnoho komerčně úspěšných her. Pro svou velmi přívětivou cenovou politiku a možnost kompilovat hry pro širokou škálu platforem od konzolí po mobilní zařízení se stal \textbf{oblíbeným nástrojem začínajících vývojářů a malých týmů}. Uživateli poskytuje mnoho nástrojů a knihoven, od editoru scény po subsystém pro navigaci entit v herním světě. Libovolnou další funkcionalitu lze přidat pomocí skriptů v jazyce C\#. 

Herní scéna je hierarchií objektů - každý z nich je definován svým předkem, jménem, transformační maticí a listem komponent. Komponenty jsou základním stavebním prvkem, kterým dodáváme objektům jejich vlastnosti - např. schopnost mít vizuální reprezentaci, schopnost kolidovat s okolními objekty. Unity poskytuje mnoho předpřipravených komponent, uživatel může definovat vlastní jako skripty dědící z třídy MonoBehavior.

Jednou ze zajímavých skupin komponent jsou ty poskytnuté vestavěným \textbf{fyzikálním sybsystémem}. Jejich prostřednictvím je uživateli poskytnuto rozhraní odpovídající velké podmnožině systému Nvidia PhysX \cite{PhysX}. 

Základem je komponenta Rigidbody - jejím přidáním se z objektu stává fyzikální entita, na kterou lze působit silami. Chceme-li fyzikálnímu objektu umožnit kolidovat s dalšími objekty, přidáme mu jednu nebo více komponent typu Collider. Pro vytváření složitějších vztahů a závislostí mezi jednotlivými fyzikálními tělesy slouží Jointy - s jejich pomocí můžeme vytvořit například dveře otevíratelné v pantech či realisticky se chovající kovový řetěz.

Fyzikální simulace je velmi mocný nástroj, nevytváří však věrný obraz reality. Na mnoha místech narážíme na numerickou stabilitu a také zkrátka na fakt, že hlavní prioritou nikdy nebyla dokonalá přesnost, nýbrž schopnost vyhodnocení v reálném čase.

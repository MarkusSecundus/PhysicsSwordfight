\chapter{Technické základy}

V této kapitole čtenáře seznámíme s herním enginem Unity \cite{Unity} do míry potřebné k pochopení zbytku práce. Stručně nastíníme architekturu, kterou pro tvorbu herních systémů tento engine podporuje, a zmíníme některé jeho vestavěné knihovny - především se podrobně zaměříme na integrovaný fyzikální subsystém.


\section{Herní engine Unity} \label{unityEngineIntroSection}

První verze enginu Unity byla vydána v roce 2005. Od té doby bylo vydáno mnoho verzí, přidáno mnoho funkcionalit a mnoho dalších prohlášeno za zastaralé. Tvůrcům se dařilo držet krok s dobou, v dnešní době jde o velmi vyspělý a moderní engine, který uživatelům nabízí \textbf{široký ekosystém nástrojů}, ať už jde o integrované komponenty, nebo balíčky třetích stran. 

Jednou z jeho velkých sil je \textbf{všestrannost} - zvládá stejně dobře 2D i 3D hry, výsledný spustitelný produkt lze vyexportovat pro širokou škálu platforem - desktopové, mobilní, konzole i web.

Pro programování herní logiky je zde podporován jazyk C\#. Jako runtime je dosud používáno postarší \textbf{Mono}, které umožňuje nanejvýše \textbf{C\# verze 9} s pár drobnostmi nepodporovanými, avšak stále jde o vcelku moderní jazyk, který programátorovi umožňuje pohodlnou práci. Interakce s knihovnami třetích stran, které závisejí na některých součástech moderního frameworku .NET, může činit problémy, avšak typicky nejde o nepřekonatelnou překážku.

Jde o \textbf{komerční produkt s uzavřenou licencí}, avšak cenová politika je více než přívětivá. Pro nekomerční projekty a projekty nepřesahující určitou hranici celkového ročního zisku je \textbf{použití enginu zcela zdarma}. Právní úprava nijak nebrání vydávání samostatných projektů v enginu tvořených pod opensource licencí. Dokumentace není celkově na špatné úrovni a těch pár míst, kde pokulhává, vynahrazují velmi živá komunitní fóra.
\bigbreak
V této kapitole si představíme základní principy použití enginu v rozsahu nutném pro vysvětlení zbytku práce. Jejich kompletnější popis čtenář najde v oficielní dokumentaci \cite{Unity}. 

\subsection{Herní objekty a komponenty}

\subsubsection*{Scéna}
Základním prvkem je \textbf{scéna} - ta odpovídá jedné oblasti ve hře. Scéna může být aktivní vždy jen jedna, hráč mezi nimi přechází.

\subsubsection*{Herní objekt}
Scéna je popsána hierarchií \textbf{herních objektů} (třída UnityEngine.GameObject). Každý herní objekt je definován svou pozicí v hierarchii (svým otcem), transformační maticí (udává pozici v herním světě) a jménem\footnote{Jméno slouží pro dokumentační a debugovací účely.} a najdeme v něm (volitelně prázdný) list dodatečných komponent.

\subsubsection*{Komponenty}
Komponenty jsou základními modulárními stavebními prvky, ze kterých skládáme herní logiku. Herní engine nám poskytuje velké množství již hotových - např. jednu, skrze kterou lze definovat grafickou reprezentaci objektu, další, jež nese zodpovědnost za vykreslení této reprezentace - takto by bylo možné pokračovat velmi dlouho. Uživatel může vytvořit vlastní typ komponenty tak, že ve skriptu definuje třídu dědící z UnityEngine.MonoBehavior. Následně mu již nic nebrání vybrat si v editoru herní objekt a novou instanci komponenty (její jméno odpovídá jménu třídy) do něj přidat.

Každá komponenta může nést data a herní logiku, ty jsou definovány jednoduše skrze instanční proměnné a metody.  

\subsubsection*{Serializace}

Při práci na hře často narazíme na situaci, kdy by bylo užitečné moci nastavit část dat, které komponenta nese, ručně z editoru. Engine nám toto umožní.

Jakoukoliv proměnnou, která je deklarovaná jako public či anotovaná atributem [UnityEngine.SerializeField], se editor pokusí poskytnout k editaci.
\begin{itemize}
    \item Primitivní a vestavěné typy zpravidla nečiní problém.
    \item Pro typy dědící z UnityEngine.Object je poskytnuto pole, do kterého je možné přetáhnout jakýkoliv objekt ze scény či prefab.
    \item Uživatelsky definované třídy musí být anotovány jako [System.Serializable] - jejich editor pak sestává rekurzivně z políček odpovídajících jejich proměnným, instance je vytvořena automaticky skrze výchozí konstruktor.
    \item Proměnná nesmí být typu rozhranní, až do nedávna nebyly podporovány ani typy s generickým parametrem.
    \item Z datových struktur jsou podporovány pouze obyčejné pole a System.Collections.Generic.List<>.
\end{itemize}
Dalším omezením je, že musí jít vždy o proměnné - properties podporovány nejsou.

Tato omezení - především nemožnost používat interfacy a properties\footnote{Nepodporu složitějších datových struktur lze napravit použitím pokročilých technik pro vytváření vlastních editorových oken. Nepodpora generik pak činí problém spíše jen u sealed typů a structů, ze kterých není možné odvodit negenerického potomka.} - mohou programátorovi značně ztížit snahy o dodržování dobrých praktik objektového programování.

Důvodem je, že tato úprava polí v editoru je specielním případem použití \textbf{standardního serializačního subsystému} enginu Unity. Na ten narazíme kdekoliv, kde je třeba interně ukládat herní stav do podoby, ze které bude možné jej později rekonstruovat. Mimo jiné je rovněž zodpovědný za to, aby ve finální sestavené verzi hry bylo načítání scény pro hráče co nejrychlejší. Je tedy jen přirozené, že je koncipován především pro co možná nejvyšší výkon - z čehož plynou výše zmíněná omezení.

\subsubsection*{Prefaby}
Standardní serializační systém však programátorovi přináší i mnoho výhod. Jeho nápomocí nám je umožněno jednoduše přetáhnout herní objekt z objektové hierarchie do souborového systému a vytvořit z něj tzv. \textbf{prefab}. Takto osamostatněný objekt můžeme následně referovat libovolněkrát v libovolné scéně a systém se postará, aby veškeré změny, které byly provedeny přímo na prefabu, byly přeneseny do jednotlivých instancí, zatímco změny oproti prefabu, kterých jsme se dopustili na konkrétní instanci, zůstanou zachovány. Rovněž je možné vytvořit \textbf{variantu prefabu} - samostatný prefab, který se odkazuje na jiný prefab jakožto svou předlohu a vůči ní přibaluje nějaké změny. 

Jak vidíme, jde o mocný nástroj umožňující organizaci herních objektů podobně flexibilním způsobem, jaký nabízí dědičnost v oblasti objektového programování. 

\subsubsection*{Komunikace mezi komponentami} \label{communicationBetweenComponentsSubsubsection}

Jakákoliv trochu komplexnější herní logika se neobejde bez vzájemné komunikace mezi komponentami. Unity nám k tomuto účelu nabízí hned několik základních cest.

První z nich je zkrátka na instanci druhé komponenty \textbf{zavolat metodu, kterou chceme}. Výhodou je, že metoda může mít libovolné množství argumentů, být generická, ... celkově je možné využívat plně možností, které jazyk C\# poskytuje. Nevýhodou je, že musíme mít přímý odkaz na instanci, na které volání uskutečňujeme.

Druhou možností je \textbf{UnityEvent}. Jde o obdobu klasických C\# delegátů, která však podporuje serializaci a je ji tedy možné konfigurovat z editoru. S její pomocí komponenta může definovat callbacky, do kterých je následně v editoru zaregistrováno libovolné množství posluchačských metod patřících ostatním komponentám. Zavoláním metody Invoke() na instanci UnityEvent jsou následně zavolány všechny posluchačské metody, jedna po druhé.

Poslední možností je \textbf{posílání zpráv}. Tento mechanismus je hojně používán pro komunikaci mezi komponentami a systémem. Princip je jednodchý: na libovolném herním objektu je možné zavolat metodu SendMessage() - jejím parametrem je jméno metody, volitelně ještě libovolný objekt jako argument. Systém projde všechny komponenty náležící danému objektu a pokud nějaký z nich definuje (jedno zda veřejnou či privátní) metodu, jejíž hlavička odpovídá jménu a typu argumentu, jež jsme metodě SendMessage předali, všechny takovéto metody budou jedna po druhé zavolány.

\subsubsection*{Jak hledat komponenty}

V mnoha případech potřebujeme s instancí jiné komponenty komunikovat přímo. Jakým způsobem lze tedy odkaz na ni získat?

Nejjednodušší možností je na naší komponentě zavést serializovatelnou proměnnou, do které odkaz na druhou komponentu doplníme v editoru. 

Pokud tato možnost nepřipadá v úvahu, či je komponent mnoho a přetahovat všechny by bylo přespříliš úmorné, Unity nabízí mnoho cest, jak scénu prohledávat. Mezi základní patří:

\begin{itemize}
    \item \textbf{gameObject.GetComponent<TComponent>()} - Voláme na konkrétní instanci herního objektu. Vrátí první komponentu typu TComponent, jež se v objektu nachází, popř. null. TComponent může být konkrétní typ komponenty, rovněž to však může být rozhraní. Existuje také varianta GetComponent\underline{s}<TComponent>(), která iteruje všechny takové komponenty, pokud jich je více. Také GetComponent(s)InParent() a GetComponent(s)InChildren(), které prohledávají celou objektovou hierarchii směrem od objektu nahoru/dolu.
    \item \textbf{UnityEngine.Object.FindFirstObjectByType<TObject>()} - Statická metoda. Podobné chování jako GetComponent, avšak prohledává celou aktivní scénu. 
    \item \textbf{UnityEngine.GameObject.FindByTag()} - Rovněž prohledává celou scénu. Pro každý herní objekt je možné v editoru nastavit specielní poznávací symbol - tag - podle něj zde vyhledáváme. Vrací odkaz na herní objekt, na něm typicky ještě bude nutné zavolat GetComponent. Toto je obecně doporučovaný způsob, jak získávat odkaz na singletony.
\end{itemize}

Je však třeba podotknout, že všechny tyto možnosti zpravidla vykonávají nějakou formu lineárního hledání a nejsou tedy zcela efektivní. Velmi doporučované je provádět hledání pokud možno jen jednou při aktivaci naší komponenty, a jeho výsledek si "nakešovat" do proměnné.

\subsection{Herní smyčka}

Typická videohra běží v \textbf{nekonečné smyčce}. Jsou načteny vstupy, provedena aktualizace herního stavu, následně vykreslena grafika - jakmile je hotovo, opakujeme. 

V Unity je herní smyčka plně v režii systému, programátor může ve svých skriptech pouze \textbf{poslouchat na události}, které v jejím průběhu nastanou. Ty jsou mu typicky komunikovány pomocí výše popsaného systému posílání zpráv (viz \ref{communicationBetweenComponentsSubsubsection}).
Typickými takovými zprávami jsou:

\begin{itemize}
    \item \textbf{Update()} - Volána jednou za každý snímek. Zde by měla být updatována herní logika. Čas uplynulý od minulého snímku není předáván jako argument, nýbrž ho lze vyčíst ze statické proměnné UnityEngine.Time.deltaTime.
    \item \textbf{Start()} - Volána jednou za život objektu, těsně před tím, než je zavolán jeho první Update(). Zde by typicky mělo probíhat hledání dalších komponent a podobné inicializační operace.
    \item \textbf{Awake()} - Volána okamžitě po vytvoření objektu, tedy dříve než Start. Některé další zprávy mají okrajové případy, ve kterých rovněž mohou být zavolány dříve než Start - pokud to hrozí, je třeba provést inicializaci zde.
    \item \textbf{OnDestroy()} - Volána při zničení komponenty. Zde může uvolnit držené zdroje.
\end{itemize}
Zajímavou vlastností je, že komponenta může být nastavena jako \textbf{neaktivní} - v takovém případě nedostává zprávy Update a volání Start je odloženo. Awake a OnDestroy však stále volány jsou.

Rovněž je užitečné vědět, že veškeré zprávy herní smyčky jsou volány \textbf{sekvenčně na hlavním vlákně}. Multithreading v Unity nalezneme pouze na specifických místech, a na těch si tvůrci dali záležet, aby byl uživatel velmi důrazně varován.


\subsection{Knihovny}

Kromě standardní knihovny jazyka C\# Unity poskytuje \textbf{mnoho dalších knihoven} nabízejících funkcionalitu užitečnou specificky při tvorbě videoher.

Samozřejmě zde najdeme mnoho nástrojů pro pokročilou \textbf{interakci s hierarchií herních objektů} - ničit objekty či vytvářet nové za běhu není problém. 

Dále zde najdeme například široký výběr \textbf{matematických primitiv} - vektory (2D a 3D) a matice umožňující provádět základní operace známé z lineární algebry a mnoho typů reprezentujících další geometrické objekty jako přímky či roviny.

Velkým tématem pro videohry je jak známo například \textbf{vykreslování grafiky} s pomocí GPU, \textbf{animace}, či \textbf{navigace herních postav terénem}. Pro každou z těchto oblastí a mnoho dalších disponuje Unity dedikovaným subsystémem. O šířce jeho záběru se lze přesvědčit v oficielní dokumentaci \cite{Unity}.

\section{Fyzikální subsystém enginu Unity}

\begin{itemize}
    \item zjednodušená dynamika a kinematika pevného tělesa
    \item je to vlastní Uniťácké API postavené nad backendem nVidia PhysX, ale poskytuje jenom podmnožinu kompletní PhysX funkcionality
    \item uvést reference na Unity a na PhysX dokumentaci\footnote{Chci mít odděleně referenci na Unity a na Unity-docs, nebo jenom Unity a nechat ho aby url neukazovalo na main page ale na docs?}
    \item zmínit že Unity má taky 2D Physics, co jsou úplně odděleně a za backend maj Box2D 
    \item vede si vlastní reprezentaci celé scény, při počítání vychází jenom z ní, před a po každém kroku se provede synchronizace s herním světem (updatnou transformy apod.)
    \item FixedUpdate
\end{itemize}


\subsection{Rigidbody}
\begin{itemize}
    \item non-kinematic VS kinematic
    \item properties (mass, center-of-mass+inertia-tensor, (angular) drag, axis-lock,...)
    \item jak se chová vůči transform-hierarchii
          \begin{itemize}
            \item fyzika používá globální souřadnice objektů
            \item collidery v potomcích patří otcovskému rigidbody
            \item rigidbody uvnitř rigidbody -> undefined behavior
          \end{itemize}
\end{itemize}

\subsection{Colliders}
\begin{itemize}
    \item zmínit že to je nejvíc základní a používaná funkcionalita physics systému, kvůli který ho spousta her includuje i když nepoužívají žádný non-kinematic rigidbodies a tak.  
    \item primitivní tvary, jejich skládání, nefunkčnost obecné maticové deformace (vždy zachovává kvádrovost, kulovost, kapsulovost)
    \item NEodpovídá(!) přesně tvaru meshe a v tom je pointa, ale když se umístěj šikovně, nijak to nekazí hráčský zážitek
    \item (letmo zmínit) mesh collidery existují - ale je u nich dost omezení, mají smysl jenom na terén apod.
    \item statické vs dynamické collidery (úplně samostatné / kinematic / non-kinematic) - co s čím koliduje a jak se chovaj když se pohybujou (pohyblivé collidery by měly být na nějakém (klidně kinematickém) rigidbody)
    \item trigger collidery
    \item Layers - co s čím koliduje; slouží i pro jinou funkcionalitu naprosto nesouvisející s fyzikou(!) ( další problémy rozebereme v \ref{swordCollisionsSection})
    \item zpráva OnCollisionXx / OnTriggerXx
    \item discrete VS continuous collision detection (jenom že existuje, podrobněji v \ref{swordCollisionsSection})
\end{itemize}

\subsection{Joints}
\begin{itemize}
    \item (velmi stručně) co je constraint solver a jaký používá Unity
    \item strohý výčet jmen jointů a že všechny jsou to speciální případ Configurable Jointu (neboli D6 jointu jak ho zná PhysX)
    \item představení Configurable Jointu
    \item anchor, connectedAnchor
    \item locked/limited/free pro každý degree of freedom
    \item primary, secondary, tertiary axis, vůči čemu jsou rotace relativní (podrobněji rozebereme v \ref{howToSetJointsTargetRotationSection})
    \item positional\&angular drive - síly (spring VS damper), cílová pozice (nestabilní, alternativa nastavení connectedAnchoru) a rotace, RotationDriveMode (Slerp VS X+YZ - jenom letmo zmínit, "Slerp se choval pěkně a tak jsme ho vybrali"), Target (angular) velocity
    \item massScale VS connectedMassScale
    \item stabilita, flag EnablePreprocessing, projekce (projection mode+distance+angle)
\end{itemize}


\subsection{Stabilita simulace}
\begin{itemize}
    \item všechno to je jenom hodně hrubá aproximace, priorita je aby to běželo rychle a dalo se rozběhnout na GPU
    \item postup simulace po krocích, tunelování
    \item přesnost IEEE floatu - hodně malé/velké objekty, zaokrouhlovací chyba
    \item constraint solver, nesplnitelné constrainty, iterativní metody
    \item to, že collidery neodpovídají meshům, taky nepřidává přesnosti
    \item ladění - parametry fixedFrameDuration, iterationCount, který constraint solver se používá apod.
    \item zmínit vestavěný Physics Debugger
\end{itemize}


\section{Shrnutí}

Unity je velmi vyspělý engine, který za sebou má desetiletí vývoje a s jeho pomocí bylo vytvořeno mnoho komerčně úspěšných her. Pro svou velmi přívětivou cenovou politiku a možnost kompilovat hry pro širokou škálu platforem od konzolí po mobilní zařízení se stal \textbf{oblíbeným nástrojem začínajících vývojářů a malých týmů}. Uživateli poskytuje mnoho nástrojů a knihoven, od editoru scény po subsystém pro navigaci entit v herním světě. Libovolnou další funkcionalitu lze přidat pomocí skriptů v jazyce C\#. 

Herní scéna je hierarchií objektů - každý z nich je definován svým předkem, jménem, transformační maticí a listem komponent. Komponenty jsou základním stavebním prvkem, kterým dodáváme objektům jejich vlastnosti - např. schopnost mít vizuální reprezentaci, schopnost kolidovat s okolními objekty. Unity poskytuje mnoho předpřipravených komponent, uživatel může definovat vlastní jako skripty dědící z třídy MonoBehavior.

Jednou ze zajímavých skupin komponent jsou ty poskytnuté vestavěným \textbf{fyzikálním sybsystémem}. Jejich prostřednictvím je uživateli poskytnuto rozhraní odpovídající velké podmnožině systému Nvidia PhysX \cite{PhysX}. 

Základem je komponenta Rigidbody - jejím přidáním se z objektu stává fyzikální entita, na kterou lze působit silami. Chceme-li fyzikálnímu objektu umožnit kolidovat s dalšími objekty, přidáme mu jednu nebo více komponent typu Collider. Pro vytváření složitějších vztahů a závislostí mezi jednotlivými fyzikálními tělesy slouží Jointy - s jejich pomocí můžeme vytvořit například dveře otevíratelné v pantech či realisticky se chovající kovový řetěz.

Fyzikální simulace je velmi mocný nástroj, nevytváří však věrný obraz reality. Na mnoha místech narážíme na numerickou stabilitu a také zkrátka na fakt, že hlavní prioritou nikdy nebyla dokonalá přesnost, nýbrž schopnost vyhodnocení v reálném čase.

\chapter{Technické základy}

V této kapitole čtenáře seznámíme s herním enginem Unity \cite{Unity} do míry potřebné k pochopení zbytku práce. Stručně nastíníme architekturu, kterou pro tvorbu herních systémů tento engine podporuje, a zmíníme některé jeho vestavěné knihovny - především se podrobně zaměříme na integrovaný fyzikální subsystém.


\section{Herní engine Unity} \label{unityEngineIntroSection}

První verze enginu Unity byla vydána v roce 2005. Od té doby bylo vydáno mnoho verzí, přidáno mnoho funkcionalit a mnoho dalších prohlášeno za zastaralé. Tvůrcům se dařilo držet krok s dobou, v dnešní době jde o velmi vyspělý a moderní engine, který uživatelům nabízí \textbf{široký ekosystém nástrojů}, ať už jde o integrované komponenty, nebo balíčky třetích stran. 

Jednou z jeho velkých sil je \textbf{všestrannost} - zvládá stejně dobře 2D i 3D hry, výsledný spustitelný produkt lze vyexportovat pro širokou škálu platforem - desktopové, mobilní, konzole i web.

Pro programování herní logiky je zde podporován jazyk C\#. Jako runtime je dosud používáno postarší \textbf{Mono}, které umožňuje nanejvýše \textbf{C\# verze 9} s pár drobnostmi nepodporovanými, avšak stále jde o vcelku moderní jazyk, který programátorovi umožňuje pohodlnou práci. Interakce s knihovnami třetích stran, které závisejí na některých součástech moderního frameworku .NET, může činit problémy, avšak typicky nejde o nepřekonatelnou překážku.

Jde o \textbf{komerční produkt s uzavřenou licencí}, avšak cenová politika je více než přívětivá. Pro nekomerční projekty a projekty nepřesahující určitou hranici celkového ročního zisku je \textbf{použití enginu zcela zdarma}. Právní úprava nijak nebrání vydávání samostatných projektů v enginu tvořených pod opensource licencí. Dokumentace není celkově na špatné úrovni a těch pár míst, kde pokulhává, vynahrazují velmi živá komunitní fóra.
\bigbreak
V této kapitole si představíme základní principy použití enginu v rozsahu nutném pro vysvětlení zbytku práce. Jejich kompletnější popis čtenář najde v oficielní dokumentaci \cite{Unity}. 

\subsection{Herní objekty a komponenty}

\subsubsection*{Scéna}
Základním prvkem je \textbf{scéna} - ta odpovídá jedné oblasti ve hře. Scéna může být aktivní vždy jen jedna, hráč mezi nimi přechází.

\subsubsection*{Herní objekt}
Scéna je popsána hierarchií \textbf{herních objektů} (třída UnityEngine.GameObject). Každý herní objekt je definován svou pozicí v hierarchii (svým otcem), transformační maticí (udává pozici v herním světě) a jménem\footnote{Jméno slouží pro dokumentační a debugovací účely.} a najdeme v něm (volitelně prázdný) list dodatečných komponent.

\subsubsection*{Komponenty}
Komponenty jsou základními modulárními stavebními prvky, ze kterých skládáme herní logiku. Herní engine nám poskytuje velké množství již hotových - např. jednu, skrze kterou lze definovat grafickou reprezentaci objektu, další, jež nese zodpovědnost za vykreslení této reprezentace - takto by bylo možné pokračovat velmi dlouho. Uživatel může vytvořit vlastní typ komponenty tak, že ve skriptu definuje třídu dědící z UnityEngine.MonoBehavior. Následně mu již nic nebrání vybrat si v editoru herní objekt a novou instanci komponenty (její jméno odpovídá jménu třídy) do něj přidat.

Každá komponenta může nést data a herní logiku, ty jsou definovány jednoduše skrze instanční proměnné a metody.  

\subsubsection*{Serializace}

Při práci na hře často narazíme na situaci, kdy by bylo užitečné moci nastavit část dat, které komponenta nese, ručně z editoru. Engine nám toto umožní.

Jakoukoliv proměnnou, která je deklarovaná jako public či anotovaná atributem [UnityEngine.SerializeField], se editor pokusí poskytnout k editaci.
\begin{itemize}
    \item Primitivní a vestavěné typy zpravidla nečiní problém.
    \item Pro typy dědící z UnityEngine.Object je poskytnuto pole, do kterého je možné přetáhnout jakýkoliv objekt ze scény či prefab.
    \item Uživatelsky definované třídy musí být anotovány jako [System.Serializable] - jejich editor pak sestává rekurzivně z políček odpovídajících jejich proměnným, instance je vytvořena automaticky skrze výchozí konstruktor.
    \item Proměnná nesmí být typu rozhranní, až do nedávna nebyly podporovány ani typy s generickým parametrem.
    \item Z datových struktur jsou podporovány pouze obyčejné pole a System.Collections.Generic.List<>.
\end{itemize}
Dalším omezením je, že musí jít vždy o proměnné - properties podporovány nejsou.

Tato omezení - především nemožnost používat interfacy a properties\footnote{Nepodporu složitějších datových struktur lze napravit použitím pokročilých technik pro vytváření vlastních editorových oken. Nepodpora generik pak činí problém spíše jen u sealed typů a structů, ze kterých není možné odvodit negenerického potomka.} - mohou programátorovi značně ztížit snahy o dodržování dobrých praktik objektového programování.

Důvodem je, že tato úprava polí v editoru je specielním případem použití \textbf{standardního serializačního subsystému} enginu Unity. Na ten narazíme kdekoliv, kde je třeba interně ukládat herní stav do podoby, ze které bude možné jej později rekonstruovat. Mimo jiné je rovněž zodpovědný za to, aby ve finální sestavené verzi hry bylo načítání scény pro hráče co nejrychlejší. Je tedy jen přirozené, že je koncipován především pro co možná nejvyšší výkon - z čehož plynou výše zmíněná omezení.

\subsubsection*{Prefaby}
Z faktu, že je použita takováto standardní serializace, však plynou i výhody. Její nápomocí nám je umožněno jednoduše přetáhnout herní objekt z objektové hierarchie do souborového systému a vytvořit z něj tzv. \textbf{prefab}.

\subsubsection*{Posílání zpráv}
\begin{itemize}
    \item srovnání VS UnityEvent VS C\# delegáti 
\end{itemize}

\begin{itemize}
    %\item scéna - hierarchie gameobjectů
    %\item gameobject - kontejner do kterého se naházejí komponenty
    %\item komponenta - modul poskytující objektu nějaký kousek funkcionality; builtin, nebo to je uživatelsky definovaná třída; může obsahovat nějaká data (nastavitelná v editoru) a nějakou herní logiku (která příp. zahrnuje komunikaci s ostatními komponentami a gameobjecty)
    %\item serializace - z editoru se dají editovat public/[SerializeField] fieldy ; nekompatibilní s properties, interfacama a jinýma datovýma strukturama než pole/list - omezující když chce člověk používat klasické dobré OOP practices  
    \item z herního objektu se dá vytvořit prefab
\end{itemize}


\subsection{Herní smyčka}
\begin{itemize}
    \item zpráva Update, deltaTime
    \item všechno probíhá sekvenčně na main threadu
\end{itemize}

\subsection{Základní knihovny}
\begin{itemize}
    \item (vše pouze zmínit že existuje)
    \item matematická primitiva - Vector3, Ray, matice, apod.
    \item instanciace gameobjectů a komponent za runtimu
    \item Vykreslování grafiky
    \item NavMesh
    \item extrémně moc dalších věcí
\end{itemize}


\section{Fyzikální subsystém enginu Unity}

\subsection{Představení}
\begin{itemize}
    \item zjednodušená dynamika a kinematika pevného tělesa
    \item je to vlastní Uniťácké API postavené nad backendem nVidia PhysX, ale poskytuje jenom podmnožinu kompletní PhysX funkcionality
    \item uvést reference na Unity a na PhysX dokumentaci\footnote{Chci mít odděleně referenci na Unity a na Unity-docs, nebo jenom Unity a nechat ho aby url neukazovalo na main page ale na docs?}
    \item zmínit že Unity má taky 2D Physics, co jsou úplně odděleně a za backend maj Box2D 
    \item vede si vlastní reprezentaci celé scény, při počítání vychází jenom z ní, před a po každém kroku se provede synchronizace s herním světem (updatnou transformy apod.)
    \item FixedUpdate
\end{itemize}


\subsection{Rigidbody}
\begin{itemize}
    \item non-kinematic VS kinematic
    \item properties (mass, center-of-mass+inertia-tensor, (angular) drag, axis-lock,...)
    \item jak se chová vůči transform-hierarchii
          \begin{itemize}
            \item fyzika používá globální souřadnice objektů
            \item collidery v potomcích patří otcovskému rigidbody
            \item rigidbody uvnitř rigidbody -> undefined behavior
          \end{itemize}
\end{itemize}

\subsection{Colliders}
\begin{itemize}
    \item zmínit že to je nejvíc základní a používaná funkcionalita physics systému, kvůli který ho spousta her includuje i když nepoužívají žádný non-kinematic rigidbodies a tak.  
    \item primitivní tvary, jejich skládání, nefunkčnost obecné maticové deformace (vždy zachovává kvádrovost, kulovost, kapsulovost)
    \item NEodpovídá(!) přesně tvaru meshe a v tom je pointa, ale když se umístěj šikovně, nijak to nekazí hráčský zážitek
    \item (letmo zmínit) mesh collidery existují - ale je u nich dost omezení, mají smysl jenom na terén apod.
    \item statické vs dynamické collidery (úplně samostatné / kinematic / non-kinematic) - co s čím koliduje a jak se chovaj když se pohybujou (pohyblivé collidery by měly být na nějakém (klidně kinematickém) rigidbody)
    \item trigger collidery
    \item Layers - co s čím koliduje; slouží i pro jinou funkcionalitu naprosto nesouvisející s fyzikou(!) ( další problémy rozebereme v \ref{swordCollisionsSection})
    \item zpráva OnCollisionXx / OnTriggerXx
    \item discrete VS continuous collision detection (jenom že existuje, podrobněji v \ref{swordCollisionsSection})
\end{itemize}

\subsection{Joints}
\begin{itemize}
    \item (velmi stručně) co je constraint solver a jaký používá Unity
    \item strohý výčet jmen jointů a že všechny jsou to speciální případ Configurable Jointu (neboli D6 jointu jak ho zná PhysX)
    \item představení Configurable Jointu
    \item anchor, connectedAnchor
    \item locked/limited/free pro každý degree of freedom
    \item primary, secondary, tertiary axis, vůči čemu jsou rotace relativní (podrobněji rozebereme v \ref{howToSetJointsTargetRotationSection})
    \item positional\&angular drive - síly (spring VS damper), cílová pozice (nestabilní, alternativa nastavení connectedAnchoru) a rotace, RotationDriveMode (Slerp VS X+YZ - jenom letmo zmínit, "Slerp se choval pěkně a tak jsme ho vybrali"), Target (angular) velocity
    \item massScale VS connectedMassScale
    \item stabilita, flag EnablePreprocessing, projekce (projection mode+distance+angle)
\end{itemize}


\subsection{Stabilita simulace}
\begin{itemize}
    \item všechno to je jenom hodně hrubá aproximace, priorita je aby to běželo rychle a dalo se rozběhnout na GPU
    \item postup simulace po krocích, tunelování
    \item přesnost IEEE floatu - hodně malé/velké objekty, zaokrouhlovací chyba
    \item constraint solver, nesplnitelné constrainty, iterativní metody
    \item to, že collidery neodpovídají meshům, taky nepřidává přesnosti
    \item ladění - parametry fixedFrameDuration, iterationCount, který constraint solver se používá apod.
    \item zmínit vestavěný Physics Debugger
\end{itemize}


\section{Shrnutí}

Unity je velmi vyspělý engine, který za sebou má desetiletí vývoje a s jeho pomocí bylo vytvořeno mnoho komerčně úspěšných her. Pro svou velmi přívětivou cenovou politiku a možnost kompilovat hry pro širokou škálu platforem od konzolí po mobilní zařízení se stal \textbf{oblíbeným nástrojem začínajících vývojářů a malých týmů}. Uživateli poskytuje mnoho nástrojů a knihoven, od editoru scény po subsystém pro navigaci entit v herním světě. Libovolnou další funkcionalitu lze přidat pomocí skriptů v jazyce C\#. 

Herní scéna je hierarchií objektů - každý z nich je definován svým předkem, jménem, transformační maticí a listem komponent. Komponenty jsou základním stavebním prvkem, kterým dodáváme objektům jejich vlastnosti - např. schopnost mít vizuální reprezentaci, schopnost kolidovat s okolními objekty. Unity poskytuje mnoho předpřipravených komponent, uživatel může definovat vlastní jako skripty dědící z třídy MonoBehavior.

Jednou ze zajímavých skupin komponent jsou ty poskytnuté vestavěným \textbf{fyzikálním sybsystémem}. Jejich prostřednictvím je uživateli poskytnuto rozhraní odpovídající velké podmnožině systému Nvidia PhysX \cite{PhysX}. 

Základem je komponenta Rigidbody - jejím přidáním se z objektu stává fyzikální entita, na kterou lze působit silami. Chceme-li fyzikálnímu objektu umožnit kolidovat s dalšími objekty, přidáme mu jednu nebo více komponent typu Collider. Pro vytváření složitějších vztahů a závislostí mezi jednotlivými fyzikálními tělesy slouží Jointy - s jejich pomocí můžeme vytvořit například dveře otevíratelné v pantech či realisticky se chovající kovový řetěz.

Fyzikální simulace je velmi mocný nástroj, nevytváří však věrný obraz reality. Na mnoha místech narážíme na numerickou stabilitu a také zkrátka na fakt, že hlavní prioritou nikdy nebyla dokonalá přesnost, nýbrž schopnost vyhodnocení v reálném čase.

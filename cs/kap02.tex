\chapter{Základy}
(v této sekci si představíme herní engine Unity a jeho fyzikální subsystém)

\section{Herní engine Unity}

(zákl. úvod)
- struktura projektu: modely, textury, C\# skripty

(model gameobjectů a herních komponent)
- builtin VS custom MonoBehavior

(posílání zpráv)
- (vs UnityEvent)

(game loop)

(scéna)



\section{Fyzika}

(vlastní API postavené nad backendem nVidia PhysX)
- letmo zmínit 2D Physics, co jsou úplně odděleně a za backend maj Box2D 
- ale neexposuje z něj všechnu funkcionalitu
- běží ve vlastním vlákně (/na GPU), ale API to od uživatele víceméně odstiňuje
- vede si vlastní reprezentaci celé scény, při počítání vychází jenom z ní, před a po každém kroku se provede synchronizace s herním světem (updatnou transformy apod.)

(Rigidbody)
- non-kinematic VS kinematic
- properties (mass, center-of-mass, inertia-tensor, (angular) drag, axis-lock, iteration count,...)
- ?? pozice objektu (používá globální souřadnice), rb.transfrm.position =.. VS rb.position =.. VS rb.MovePosition(..)

(Colliders)
- zmínit že to je nejvíc základní a nosná funkcionalita physics systému, kvůli který ho spousta her includuje i když nepoužívají žádný non-kinematic rigidbodies a tak.  
- primitivní tvary, jejich skládání, nefunkčnost maticové deformace
- statické vs dynamické collidery (úplně samostatné / kinematic / non-kinematic)
- NEodpovídá(!) přesně tvaru meshe
- mesh collidery - omezení (256 vertices max, statické) a situace kdy stojí za to je používat (statický terén)
- trigger collidery
- auto počítání center-of-mass a intertia tensor podle colliderů

(Physics Material)
- aproximace pro tření povrchů apod.

(Joints)
- co je constraint solver a jaký používá unity
- velmi stručný výčet jmen jointů a že všechny jsou to speciální případ Configurable Jointu (neboli D6 jointu jak ho zná PhysX)
- představení Configurable Jointu
    - anchor, connectedAnchor
    - locked/limited/free pro každý degree of freedom
    - primary, secondary, tertiary axis, vůči čemu jsou rotace relativní, jak převést z rotace v globálním úhlu nebo relativní vůči transformu, ConfiguredInWorldSpace flag
    - positional\&angular drive - síly (spring VS damper), cílová pozice (nestabilní, alternativa nastavení connectedAnchoru) a rotace, RotationDriveMode (Slerp VS X+YZ - jenom letmo zmínit, "Slerp se choval pěkně a tak jsme ho vybrali"), Target (angular) velocity
    - massScale VS connectedMassScale
    - stabilita, flag EnablePreprocessing, projekce (projection mode+distance+angle)

(Globální vlastnosti)
- fixed frame duration
- iteration count
- constraint solver co se má použít


\section{Shrnutí}